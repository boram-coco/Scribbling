[
  {
    "objectID": "posts/논문.html",
    "href": "posts/논문.html",
    "title": "Scribbling",
    "section": "",
    "text": "논문\nXia, F., Sun, K., Yu, S., Aziz, A., Wan, L., Pan, S., & Liu, H. (2021). Graph learning: A survey. IEEE Transactions on Artificial Intelligence, 2(2), 109-127.\nNickel, M., Murphy, K., Tresp, V., & Gabrilovich, E. (2015). A review of relational machine learning for knowledge graphs. Proceedings of the IEEE, 104(1), 11-33.\nYang, Z., Cohen, W., & Salakhudinov, R. (2016, June). Revisiting semi-supervised learning with graph embeddings. In International conference on machine learning (pp. 40-48). PMLR.\n\nGNN\nhttps://arxiv.org/ftp/arxiv/papers/1812/1812.08434.pdf\nF.Scarselli, M.Gori, “The graph neural network model,” IEEE Transactions on Neural Networks, 2009\nT. N. Kipf and M. Welling, “Semi-supervised classification with graph convolutional networks,” in Proc. of ICLR, 2017.\nZ. Wu, S. Pan, F. Chen, G. Long, C. Zhang, Philip S. Yu, “A Comprehensive Survey on Graph Neural Networks”, arXiv:1901.00596\nD. Xu, Y. Zhu, C. B. Choy, and L. Fei-Fei, “Scene graph generation by iterative message passing,” in Proc. of CVPR, vol. 2, 2017\nJ. Johnson, A. Gupta, and L. Fei-Fei, “Image generation from scene graphs,” in Proc. of CVPR, 2018\nX. Wang, Y. Ye, and A. Gupta, “Zero-shot recognition via semantic embeddings and knowledge graphs,” in CVPR 2018"
  },
  {
    "objectID": "posts/hadamangeo/VAE.html",
    "href": "posts/hadamangeo/VAE.html",
    "title": "VAE(-ing)",
    "section": "",
    "text": "https://arxiv.org/pdf/1312.6114.pdf"
  },
  {
    "objectID": "posts/hadamangeo/VAE.html#오토인코더",
    "href": "posts/hadamangeo/VAE.html#오토인코더",
    "title": "VAE(-ing)",
    "section": "오토인코더",
    "text": "오토인코더\n\nEncoder, Decoder 네트워크로 구성된 모델\n학습 데이터-> encoder에 입력값"
  },
  {
    "objectID": "posts/hadamangeo/Czech-banking-customer-trans-analysis.html",
    "href": "posts/hadamangeo/Czech-banking-customer-trans-analysis.html",
    "title": "Scribbling",
    "section": "",
    "text": "Czech\n\n\n\n\n\n\n\ndata map.gif\n\n\nThanks to TSilveira for data visualization examples: https://www.kaggle.com/tsilveira/applying-heatmaps-for-categorical-data-analysis\n\nimport numpy as np # \nimport pandas as pd # \n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ncolor = sns.color_palette()\n\n%matplotlib inline\n\nfrom datetime import datetime\nfrom datetime import date\nfrom plotly import tools\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\n\nfrom collections import Counter\n\nimport os\nprint(os.listdir(\"../czech-banking-fin-analysis\"))\n\n\n\n\n['.git', '.ipynb_checkpoints', 'account.csv', 'card.csv', 'client.csv', 'Czech-banking-customer-trans-analysis.ipynb', 'czech.jpg', 'Data dictionary.pdf', 'disp.csv', 'district.csv', 'loan.csv', 'order.csv', 'Plots', 'trans.csv']\n\n\n\n#defining all necessary functions\n\ndef date_correction (df, col_name):\n    \"\"\" Function that will re-format cells into date format. Input should be in the format of YYMMDD, e.g. 950107\n    input: dataframe and column name of the dataframe\n    output: updated dataframe\n    \"\"\"\n    df [col_name] = pd.to_datetime (df [col_name], format = '%y%m%d', errors = 'coerce')\n    return df\n\ndef date_misinterp_cor (date): #correction of date misinterpretation when 45 treated as 2045 and not 1945\n    \"\"\"Function that corrects year misinterpretation when 45 treated as 2045 and not 1945\n    input: date\n    output: corrected date\"\"\"\n    if date.year > 2000: \n        date = date.replace (year = date.year - 100)\n        return date\n    else:\n        return date\n\ndef calculate_age (born_date):\n    \"\"\"Age calculation as of 31.12.1998 \n    input: born date\n    outpute: age (int)\"\"\"\n    born = born_date.year\n    return 1998 - born\n\ndef date_parsing (date):\n    \"\"\"Extracting year from a string. \n    input: a value that contains date in the first 6 symbols.\n    output: year\"\"\"\n    date = int (str (date) [0:6])\n    date2 = pd.to_datetime (date, format = '%y%m%d', errors = 'coerce')\n    if date2.year > 2000: \n        return date2.year - 100\n    else:\n        return date2.year\n    \ndef year_extract (date):\n    \"\"\" Function that will extract a year from date and return it\n        input should be date format\"\"\"\n    if date.year > 2000: \n        return date.year - 100\n    else:\n        return date.year\n    \ndef df_row_normalize(dataframe):\n    '''Normalizes the values of a given pandas.Dataframe by the total sum of each line.\n    Algorithm based on https://stackoverflow.com/questions/26537878/pandas-sum-across-columns-and-divide-each-cell-from-that-value'''\n    return dataframe.div(dataframe.sum(axis=1), axis=0)\n\n\n#loading all the datasets\n\naccounts_df = pd.read_csv ('account.csv', sep = ';')\ncards_df = pd.read_csv ('card.csv', sep = ';')\nclients_df = pd.read_csv ('client.csv', sep = ';')\ndispos_df = pd.read_csv ('disp.csv', sep = ';')\ndistrict_df = pd.read_csv ('district.csv', sep = ';')\nloan_df = pd.read_csv ('loan.csv', sep = ';')\norder_df = pd.read_csv ('order.csv', sep = ';')\ntrans_df = pd.read_csv ('trans.csv', sep = ';')\n\n\nD:\\Users\\Kusainov\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\IPython\\core\\interactiveshell.py:2785: DtypeWarning:\n\nColumns (8) have mixed types. Specify dtype option on import or set low_memory=False.\n\n\n\n\n#list of all dataframes\nfiles = [accounts_df, cards_df, clients_df, dispos_df, district_df, loan_df, order_df, trans_df]\ndate_cor_files = [trans_df, accounts_df, loan_df]\nfiles_name = ['accounts_df', 'cards_df', 'clients_df', 'dispos_df', 'district_df', 'loan_df', 'order_df', 'trans_df']\n\n\n\n\n#verifying numeric statistics and missing values in the datasets  \nfor id, item in enumerate (files): \n    print ('Dataframe name: ' + str (files_name [id]) + \" with number of rows:\" + str (item.shape [0]) + ' and columns:' + str (item.shape [1]) )\n    display (item.describe ())\n    print (item.isnull ().sum ())\n    print ('\\n')\n\nDataframe name: accounts_df with number of rows:4500 and columns:4\n\n\n\n\n\n\n  \n    \n      \n      account_id\n      district_id\n      date\n    \n  \n  \n    \n      count\n      4500.000000\n      4500.000000\n      4500.000000\n    \n    \n      mean\n      2786.067556\n      37.310444\n      951654.608667\n    \n    \n      std\n      2313.811984\n      25.177217\n      14842.188377\n    \n    \n      min\n      1.000000\n      1.000000\n      930101.000000\n    \n    \n      25%\n      1182.750000\n      13.000000\n      931227.000000\n    \n    \n      50%\n      2368.000000\n      38.000000\n      960102.000000\n    \n    \n      75%\n      3552.250000\n      60.000000\n      961101.000000\n    \n    \n      max\n      11382.000000\n      77.000000\n      971229.000000\n    \n  \n\n\n\n\naccount_id     0\ndistrict_id    0\nfrequency      0\ndate           0\ndtype: int64\n\n\nDataframe name: cards_df with number of rows:892 and columns:4\n\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n    \n  \n  \n    \n      count\n      892.000000\n      892.000000\n    \n    \n      mean\n      480.855381\n      3511.862108\n    \n    \n      std\n      306.933982\n      2984.373626\n    \n    \n      min\n      1.000000\n      9.000000\n    \n    \n      25%\n      229.750000\n      1387.000000\n    \n    \n      50%\n      456.500000\n      2938.500000\n    \n    \n      75%\n      684.250000\n      4459.500000\n    \n    \n      max\n      1247.000000\n      13660.000000\n    \n  \n\n\n\n\ncard_id    0\ndisp_id    0\ntype       0\nissued     0\ndtype: int64\n\n\nDataframe name: clients_df with number of rows:5369 and columns:3\n\n\n\n\n\n\n  \n    \n      \n      client_id\n      birth_number\n      district_id\n    \n  \n  \n    \n      count\n      5369.000000\n      5369.000000\n      5369.000000\n    \n    \n      mean\n      3359.011920\n      535114.970013\n      37.310114\n    \n    \n      std\n      2832.911984\n      172895.618429\n      25.043690\n    \n    \n      min\n      1.000000\n      110820.000000\n      1.000000\n    \n    \n      25%\n      1418.000000\n      406009.000000\n      14.000000\n    \n    \n      50%\n      2839.000000\n      540829.000000\n      38.000000\n    \n    \n      75%\n      4257.000000\n      681013.000000\n      60.000000\n    \n    \n      max\n      13998.000000\n      875927.000000\n      77.000000\n    \n  \n\n\n\n\nclient_id       0\nbirth_number    0\ndistrict_id     0\ndtype: int64\n\n\nDataframe name: dispos_df with number of rows:5369 and columns:4\n\n\n\n\n\n\n  \n    \n      \n      disp_id\n      client_id\n      account_id\n    \n  \n  \n    \n      count\n      5369.000000\n      5369.000000\n      5369.000000\n    \n    \n      mean\n      3337.097970\n      3359.011920\n      2767.496927\n    \n    \n      std\n      2770.418826\n      2832.911984\n      2307.843630\n    \n    \n      min\n      1.000000\n      1.000000\n      1.000000\n    \n    \n      25%\n      1418.000000\n      1418.000000\n      1178.000000\n    \n    \n      50%\n      2839.000000\n      2839.000000\n      2349.000000\n    \n    \n      75%\n      4257.000000\n      4257.000000\n      3526.000000\n    \n    \n      max\n      13690.000000\n      13998.000000\n      11382.000000\n    \n  \n\n\n\n\ndisp_id       0\nclient_id     0\naccount_id    0\ntype          0\ndtype: int64\n\n\nDataframe name: district_df with number of rows:77 and columns:16\n\n\n\n\n\n\n  \n    \n      \n      A1\n      A4\n      A5\n      A6\n      A7\n      A8\n      A9\n      A10\n      A11\n      A13\n      A14\n      A16\n    \n  \n  \n    \n      count\n      77.000000\n      7.700000e+01\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n      77.000000\n    \n    \n      mean\n      39.000000\n      1.338849e+05\n      48.623377\n      24.324675\n      6.272727\n      1.727273\n      6.259740\n      63.035065\n      9031.675325\n      3.787013\n      116.129870\n      5030.831169\n    \n    \n      std\n      22.371857\n      1.369135e+05\n      32.741829\n      12.780991\n      4.015222\n      1.008338\n      2.435497\n      16.221727\n      790.202347\n      1.908480\n      16.608773\n      11270.796786\n    \n    \n      min\n      1.000000\n      4.282100e+04\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      1.000000\n      33.900000\n      8110.000000\n      0.430000\n      81.000000\n      888.000000\n    \n    \n      25%\n      20.000000\n      8.585200e+04\n      22.000000\n      16.000000\n      4.000000\n      1.000000\n      5.000000\n      51.900000\n      8512.000000\n      2.310000\n      105.000000\n      2122.000000\n    \n    \n      50%\n      39.000000\n      1.088710e+05\n      49.000000\n      25.000000\n      6.000000\n      2.000000\n      6.000000\n      59.800000\n      8814.000000\n      3.600000\n      113.000000\n      3040.000000\n    \n    \n      75%\n      58.000000\n      1.390120e+05\n      71.000000\n      32.000000\n      8.000000\n      2.000000\n      8.000000\n      73.500000\n      9317.000000\n      4.790000\n      126.000000\n      4595.000000\n    \n    \n      max\n      77.000000\n      1.204953e+06\n      151.000000\n      70.000000\n      20.000000\n      5.000000\n      11.000000\n      100.000000\n      12541.000000\n      9.400000\n      167.000000\n      99107.000000\n    \n  \n\n\n\n\nA1     0\nA2     0\nA3     0\nA4     0\nA5     0\nA6     0\nA7     0\nA8     0\nA9     0\nA10    0\nA11    0\nA12    0\nA13    0\nA14    0\nA15    0\nA16    0\ndtype: int64\n\n\nDataframe name: loan_df with number of rows:682 and columns:7\n\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date\n      amount\n      duration\n      payments\n    \n  \n  \n    \n      count\n      682.000000\n      682.000000\n      682.000000\n      682.000000\n      682.000000\n      682.000000\n    \n    \n      mean\n      6172.466276\n      5824.162757\n      963027.910557\n      151410.175953\n      36.492669\n      4190.664223\n    \n    \n      std\n      682.579279\n      3283.512681\n      14616.406049\n      113372.406310\n      17.075219\n      2215.830344\n    \n    \n      min\n      4959.000000\n      2.000000\n      930705.000000\n      4980.000000\n      12.000000\n      304.000000\n    \n    \n      25%\n      5577.500000\n      2967.000000\n      950704.500000\n      66732.000000\n      24.000000\n      2477.000000\n    \n    \n      50%\n      6176.500000\n      5738.500000\n      970206.500000\n      116928.000000\n      36.000000\n      3934.000000\n    \n    \n      75%\n      6752.500000\n      8686.000000\n      971212.500000\n      210654.000000\n      48.000000\n      5813.500000\n    \n    \n      max\n      7308.000000\n      11362.000000\n      981208.000000\n      590820.000000\n      60.000000\n      9910.000000\n    \n  \n\n\n\n\nloan_id       0\naccount_id    0\ndate          0\namount        0\nduration      0\npayments      0\nstatus        0\ndtype: int64\n\n\nDataframe name: order_df with number of rows:6471 and columns:6\n\n\n\n\n\n\n  \n    \n      \n      order_id\n      account_id\n      account_to\n      amount\n    \n  \n  \n    \n      count\n      6471.000000\n      6471.000000\n      6.471000e+03\n      6471.000000\n    \n    \n      mean\n      33778.197497\n      2962.302890\n      4.939904e+07\n      3280.635698\n    \n    \n      std\n      3737.681949\n      2518.503228\n      2.888356e+07\n      2714.475335\n    \n    \n      min\n      29401.000000\n      1.000000\n      3.990000e+02\n      1.000000\n    \n    \n      25%\n      31187.500000\n      1223.000000\n      2.415918e+07\n      1241.500000\n    \n    \n      50%\n      32988.000000\n      2433.000000\n      4.975606e+07\n      2596.000000\n    \n    \n      75%\n      34785.500000\n      3645.500000\n      7.400045e+07\n      4613.500000\n    \n    \n      max\n      46338.000000\n      11362.000000\n      9.999420e+07\n      14882.000000\n    \n  \n\n\n\n\norder_id      0\naccount_id    0\nbank_to       0\naccount_to    0\namount        0\nk_symbol      0\ndtype: int64\n\n\nDataframe name: trans_df with number of rows:1056320 and columns:10\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      amount\n      balance\n      account\n    \n  \n  \n    \n      count\n      1.056320e+06\n      1.056320e+06\n      1.056320e+06\n      1.056320e+06\n      1.056320e+06\n      2.953890e+05\n    \n    \n      mean\n      1.335311e+06\n      2.936867e+03\n      9.656748e+05\n      5.924146e+03\n      3.851833e+04\n      4.567092e+07\n    \n    \n      std\n      1.227487e+06\n      2.477345e+03\n      1.394535e+04\n      9.522735e+03\n      2.211787e+04\n      3.066340e+07\n    \n    \n      min\n      1.000000e+00\n      1.000000e+00\n      9.301010e+05\n      0.000000e+00\n      -4.112570e+04\n      0.000000e+00\n    \n    \n      25%\n      4.302628e+05\n      1.204000e+03\n      9.601160e+05\n      1.359000e+02\n      2.240250e+04\n      1.782858e+07\n    \n    \n      50%\n      8.585065e+05\n      2.434000e+03\n      9.704100e+05\n      2.100000e+03\n      3.314340e+04\n      4.575095e+07\n    \n    \n      75%\n      2.060979e+06\n      3.660000e+03\n      9.802280e+05\n      6.800000e+03\n      4.960362e+04\n      7.201341e+07\n    \n    \n      max\n      3.682987e+06\n      1.138200e+04\n      9.812310e+05\n      8.740000e+04\n      2.096370e+05\n      9.999420e+07\n    \n  \n\n\n\n\ntrans_id           0\naccount_id         0\ndate               0\ntype               0\noperation     183114\namount             0\nbalance            0\nk_symbol      481881\nbank          782812\naccount       760931\ndtype: int64\n\n\n\n\nFrom the first sight only transactions dataset contains NaN values for operation, k_symbol, bank and account.\n\n#Dataframes header\nfor id, item in enumerate (files): \n    print ('Dataframe name:' + str (files_name [id]) )\n    display (item.head (n=3))\n    print ('\\n')\n\nDataframe name:accounts_df\n\n\n\n\n\n\n  \n    \n      \n      account_id\n      district_id\n      frequency\n      date\n    \n  \n  \n    \n      0\n      576\n      55\n      POPLATEK MESICNE\n      930101\n    \n    \n      1\n      3818\n      74\n      POPLATEK MESICNE\n      930101\n    \n    \n      2\n      704\n      55\n      POPLATEK MESICNE\n      930101\n    \n  \n\n\n\n\n\n\nDataframe name:cards_df\n\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type\n      issued\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n    \n  \n\n\n\n\n\n\nDataframe name:clients_df\n\n\n\n\n\n\n  \n    \n      \n      client_id\n      birth_number\n      district_id\n    \n  \n  \n    \n      0\n      1\n      706213\n      18\n    \n    \n      1\n      2\n      450204\n      1\n    \n    \n      2\n      3\n      406009\n      1\n    \n  \n\n\n\n\n\n\nDataframe name:dispos_df\n\n\n\n\n\n\n  \n    \n      \n      disp_id\n      client_id\n      account_id\n      type\n    \n  \n  \n    \n      0\n      1\n      1\n      1\n      OWNER\n    \n    \n      1\n      2\n      2\n      2\n      OWNER\n    \n    \n      2\n      3\n      3\n      2\n      DISPONENT\n    \n  \n\n\n\n\n\n\nDataframe name:district_df\n\n\n\n\n\n\n  \n    \n      \n      A1\n      A2\n      A3\n      A4\n      A5\n      A6\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      1\n      Hl.m. Praha\n      Prague\n      1204953\n      0\n      0\n      0\n      1\n      1\n      100.0\n      12541\n      0.29\n      0.43\n      167\n      85677\n      99107\n    \n    \n      1\n      2\n      Benesov\n      central Bohemia\n      88884\n      80\n      26\n      6\n      2\n      5\n      46.7\n      8507\n      1.67\n      1.85\n      132\n      2159\n      2674\n    \n    \n      2\n      3\n      Beroun\n      central Bohemia\n      75232\n      55\n      26\n      4\n      1\n      5\n      41.7\n      8980\n      1.95\n      2.21\n      111\n      2824\n      2813\n    \n  \n\n\n\n\n\n\nDataframe name:loan_df\n\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date\n      amount\n      duration\n      payments\n      status\n    \n  \n  \n    \n      0\n      5314\n      1787\n      930705\n      96396\n      12\n      8033.0\n      B\n    \n    \n      1\n      5316\n      1801\n      930711\n      165960\n      36\n      4610.0\n      A\n    \n    \n      2\n      6863\n      9188\n      930728\n      127080\n      60\n      2118.0\n      A\n    \n  \n\n\n\n\n\n\nDataframe name:order_df\n\n\n\n\n\n\n  \n    \n      \n      order_id\n      account_id\n      bank_to\n      account_to\n      amount\n      k_symbol\n    \n  \n  \n    \n      0\n      29401\n      1\n      YZ\n      87144583\n      2452.0\n      SIPO\n    \n    \n      1\n      29402\n      2\n      ST\n      89597016\n      3372.7\n      UVER\n    \n    \n      2\n      29403\n      2\n      QR\n      13943797\n      7266.0\n      SIPO\n    \n  \n\n\n\n\n\n\nDataframe name:trans_df\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n    \n  \n  \n    \n      0\n      695247\n      2378\n      930101\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      171812\n      576\n      930101\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      207264\n      704\n      930101\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n    \n  \n\n\n\n\n\n\n\n\nDates in the following dataframes were not loaded as dates:trans_df, accounts_df, cards_df, clients_df (birth date) and loan_df.\n\n#correcting dates for trans_df, accounts_df, and loan_df. \n\nfor id, item in enumerate (date_cor_files): \n    date_cor_files [id] = date_correction (item, 'date')\n\ntrans_df = date_cor_files [0]\naccounts_df = date_cor_files [1]\nloans_df = date_cor_files [2]\n\n\n#verifying transactions execution dates period in trans_df  \ntrans1 = trans_df.sort_values (['date'])\ndisplay (trans1.head (n=3))\ndisplay (trans1.tail (n=3))\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n    \n  \n  \n    \n      0\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n    \n  \n  \n    \n      1053314\n      3631495\n      3053\n      1998-12-31\n      PRIJEM\n      NaN\n      349.8\n      86982.1\n      UROK\n      NaN\n      NaN\n    \n    \n      1053320\n      3632209\n      3077\n      1998-12-31\n      PRIJEM\n      NaN\n      267.9\n      68530.7\n      UROK\n      NaN\n      NaN\n    \n    \n      1056319\n      3626540\n      2902\n      1998-12-31\n      PRIJEM\n      NaN\n      164.1\n      41642.9\n      UROK\n      NaN\n      NaN\n    \n  \n\n\n\n\nFrom above we can see that transactions given for a period from 1st of Jan 1993 till 31st of Dec 1998\n\n\n\n\nGender proportion of the bank’s customers.\nAge distribution of the bank’s customers.\nClients habitation in different regions of Czech Republic and average salaries of the regions.\nDistricts that could be attractive for future bank’s market invasion in terms of population, average salary and underrepresented clients base.\n\n“Birth number” column should be parced into 3 columns: date of birth, gender and age (as of 31.12.1998)\nInitially “Birth number” in the dataset contains both date of birth and gender: the number in the cells is in the form of YYMMDD for men and in the form YYMM+50DD for women, where YYMMDD is the date of birth.\n\n#adding new columns\nclients_df = clients_df.join (pd.DataFrame ( { 'birth_date': np.nan, 'gender': np.nan, 'age': np.nan}, index = clients_df.index))\n\n\n#next step is to fulfill new columns with data from 'birth_number' and 'age'\nclients_df ['birth_date'] = clients_df ['birth_number']\nfor ids, item in enumerate (clients_df ['birth_number']):\n    if int (str (item) [2:4]) > 50:\n        clients_df.loc [ids, 'gender'] = 0 #female\n        clients_df.loc [ids, 'birth_date'] = item - 5000 \n    else: \n        clients_df.loc [ids, 'gender'] = 1 #male #incorrect way is: clients_df.loc [ids] ['gender']         \n\n\n#converting birth_date into date format\nclients_df = date_correction (clients_df, 'birth_date') \n\n\n#correcting misinterpreted dates\nclients_df ['birth_date'] = clients_df ['birth_date'].apply (date_misinterp_cor)\n\n\n#calculating age as of on 31.12.1998 \nclients_df ['age'] = clients_df ['birth_date'].apply (calculate_age)\ndisplay (clients_df.head (n=3))\n\n\n\n\n\n  \n    \n      \n      client_id\n      birth_number\n      district_id\n      birth_date\n      gender\n      age\n    \n  \n  \n    \n      0\n      1\n      706213\n      18\n      1970-12-13\n      0.0\n      28\n    \n    \n      1\n      2\n      450204\n      1\n      1945-02-04\n      1.0\n      53\n    \n    \n      2\n      3\n      406009\n      1\n      1940-10-09\n      0.0\n      58\n    \n  \n\n\n\n\n\n#plotting customers distribution by age\nclients_df ['age'].plot (kind = 'hist',\n                    title = 'Clients distribution per age',\n                   # width = 0.75,\n                    figsize = (8, 5.8)\n                    )\n\n<matplotlib.axes._subplots.AxesSubplot at 0x21d38630>\n\n\n\n\n\n\n#Clients gender visualization\n\ntarget1 = clients_df [clients_df ['gender'] == 1.0].shape [0]\ntarget0 = clients_df [clients_df ['gender'] == 0.0].shape [0]\n\ntrace0 = go.Bar (\n    x = ['Men', 'Women'],\n    y = [target1/ (target1 + target0) *100, target0/ (target1 + target0) *100], \n    marker = dict (color=['rgba(34, 167, 240, 1)', 'rgba(222,45,38,0.8)']\n                  ),\n) \ndata = [trace0]\nlayout = go.Layout (title = 'Gender proportion (%)', autosize= False, width= 500, height= 500,\n                    )\nfig = go.Figure (data=data, layout = layout)\n#plotly.offline.iplot()\npy.iplot (fig, filename = 'test')\n\n\n\n\n\nprint ('Percentage of men: '+ str (target1/clients_df.shape [0]*100) +'%' + ' percentage of women: ' + str (target0/clients_df.shape [0]*100) + '%')\n\nPercentage of men: 50.73570497299311% percentage of women: 49.264295027006895%\n\n\n\n#enriching customer info with habitation info   \nclients_dist_df = clients_df\nclients_dist2_df = clients_dist_df.merge (district_df, left_on = 'district_id', right_on = 'A1', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (clients_df.head (n=3))\ndisplay (clients_dist2_df.head (n=3))      \n\n\n\n\n\n  \n    \n      \n      client_id\n      birth_number\n      district_id\n      birth_date\n      gender\n      age\n    \n  \n  \n    \n      0\n      1\n      706213\n      18\n      1970-12-13\n      0.0\n      28\n    \n    \n      1\n      2\n      450204\n      1\n      1945-02-04\n      1.0\n      53\n    \n    \n      2\n      3\n      406009\n      1\n      1940-10-09\n      0.0\n      58\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      client_id\n      birth_number\n      district_id\n      birth_date\n      gender\n      age\n      A1\n      A2\n      A3\n      A4\n      ...\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      1\n      706213\n      18\n      1970-12-13\n      0.0\n      28\n      18\n      Pisek\n      south Bohemia\n      70699\n      ...\n      2\n      1\n      4\n      65.3\n      8968\n      2.83\n      3.35\n      131\n      1740\n      1910\n    \n    \n      1\n      2\n      450204\n      1\n      1945-02-04\n      1.0\n      53\n      1\n      Hl.m. Praha\n      Prague\n      1204953\n      ...\n      0\n      1\n      1\n      100.0\n      12541\n      0.29\n      0.43\n      167\n      85677\n      99107\n    \n    \n      2\n      3\n      406009\n      1\n      1940-10-09\n      0.0\n      58\n      1\n      Hl.m. Praha\n      Prague\n      1204953\n      ...\n      0\n      1\n      1\n      100.0\n      12541\n      0.29\n      0.43\n      167\n      85677\n      99107\n    \n  \n\n3 rows × 22 columns\n\n\n\n\n#grouping by district (\"A2\") and population of the district ('A4'), then counting number of customers \ndistrict_clients_df = pd.DataFrame (clients_dist2_df.groupby (['A2', 'A4', 'A11'], axis = 0) ['A2'].count ())\ndistrict_clients_df.columns = ['count']\n\n#making columns out of multi-index of A3 and type_x so to make it easier to operate with values\ndistrict_clients_df.reset_index (inplace = True)\n\n#calculating portion of clients in the population of a district\ndistrict_clients_df ['portion'] = district_clients_df ['count'] / district_clients_df ['A4'] * 100\n\ndisplay (district_clients_df .head (n=5))\ndistrict_clients_df ['count'].sum ()\n\n\n\n\n\n  \n    \n      \n      A2\n      A4\n      A11\n      count\n      portion\n    \n  \n  \n    \n      0\n      Benesov\n      88884\n      8507\n      46\n      0.051753\n    \n    \n      1\n      Beroun\n      75232\n      8980\n      63\n      0.083741\n    \n    \n      2\n      Blansko\n      107911\n      8240\n      57\n      0.052821\n    \n    \n      3\n      Breclav\n      124605\n      8772\n      54\n      0.043337\n    \n    \n      4\n      Brno - mesto\n      387570\n      9897\n      155\n      0.039993\n    \n  \n\n\n\n\n5369\n\n\n\n#average value of average salaries within districts\ndistrict_df ['A11'].mean ()\n\n9031.675324675325\n\n\n\n#average value of Relative number of clients comparing to district population\ndistrict_clients_df ['portion'].mean ()\n\n0.05795326262662295\n\n\n\n#plotting Number of inhabitants vs. Average salary vs. Customers proportion within population of districts\ndistrict_clients_df2 = district_clients_df.copy ()\ndistrict_clients_df2['A4'] = district_clients_df2['A4'] / 1000000 \n\n## Initialize the matplotlib figure:\nfig2, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(12,16), sharey=False)\nfig2.tight_layout()  #When working with 'tight_layout', the subplot must be adjusted [https://stackoverflow.com/questions/7066121/how-to-set-a-single-main-title-above-all-the-subplots-with-pyplot]\nfig2.subplots_adjust(top=0.96)  #Adjusting the space for the superior title\n\n## Plot the District population\nsns.set_color_codes(\"muted\")\nsns.barplot(x=\"A4\", y=\"A2\", data=district_clients_df2, label = 'District population (mln)',color=\"b\", ax=ax1)\n## Add a legend and informative axis label\nax1.legend(ncol=2, loc=\"lower right\", frameon=True)\nax1.set(xlim=(0, 1.21), ylabel=\"\", xlabel=\"District population (mln)\")\nsns.despine(left=True, bottom=True,ax=ax1)\n\n## Plot the Average salary\nsns.set_color_codes(\"muted\")\nsns.barplot(x=\"A11\", y=\"A2\", data=district_clients_df, label=\"Average salary\", color=\"b\", ax=ax2)\n## Add a legend and informative axis label\nax2.legend(ncol=2, loc=\"lower right\", frameon=True)\nax2.set(xlim=(0, 12541), ylabel=\"\", xlabel=\"Average salary\")  #The xlim value comes from the maximum value in the dataset.\nax2.set_yticklabels([''])\nsns.despine(left=True, bottom=True, ax=ax2)\n\nsns.set_color_codes(\"muted\")\nsns.barplot(x=\"portion\", y=\"A2\", data=district_clients_df, label=\"% of clients in population\", color=\"b\", ax=ax3)\n## Add a legend and informative axis label\nax3.legend(ncol=2, loc=\"lower right\", frameon=True)\nax3.set(xlim=(0, 0.145), ylabel=\"\", xlabel=\"Relative number of clients comparing to district population (%)\")  #The xlim value comes from the maximum value in the dataset.\nax3.set_yticklabels([''])\nsns.despine(left=True, bottom=True, ax=ax3)\n\nplt.suptitle('Number of inhabitants vs. Average salary vs. Customers proportion within population of districts', fontsize=14, fontweight='bold')\nplt.show()\n\n\n\n\n\n#Plotting clients presence in different districts\nreg_count = Counter (clients_dist2_df ['A2'])\nregion_counts = pd.DataFrame.from_dict (reg_count, orient = 'index')\nregion_counts.columns = ['Number of customers']\nregion_counts2 = region_counts# / (region_counts ['Percentage_ratio'].sum ()) * 100\n\nregion_counts2.plot (kind = 'barh',\n                    title = 'Clients distribution per districts',\n                    width = 0.75,\n                    figsize = (10, 13)\n                    )\n\n<matplotlib.axes._subplots.AxesSubplot at 0x366260f0>\n\n\n\n\n\n\n#Plotting clients presence in different major regions\n\nreg_count = Counter (clients_dist2_df ['A3'])\nregion_counts = pd.DataFrame.from_dict (reg_count, orient = 'index')\nregion_counts.columns = ['Percentage_ratio']\nregion_counts2 = region_counts / (region_counts ['Percentage_ratio'].sum ()) * 100\nregion_counts2.plot (kind = 'bar',\n                    title = 'Clients distribution per regions',\n                    width = 0.75,\n                    figsize = (8, 5.8),\n                    color = [plt.cm.Paired(np.arange(len(region_counts)))])\n\n<matplotlib.axes._subplots.AxesSubplot at 0x18ddceb8>\n\n\n\n\n\n\n#Average salaries in the regions\nregion_salary_df = pd.DataFrame (district_df.groupby (['A3'], axis = 0) ['A11'].mean ()).sort_values ('A11')\ndisplay (region_salary_df.head (n=10))\n\n\n\n\n\n  \n    \n      \n      A11\n    \n    \n      A3\n      \n    \n  \n  \n    \n      east Bohemia\n      8611.181818\n    \n    \n      south Moravia\n      8728.500000\n    \n    \n      south Bohemia\n      8831.500000\n    \n    \n      west Bohemia\n      9015.400000\n    \n    \n      north Moravia\n      9049.181818\n    \n    \n      north Bohemia\n      9334.200000\n    \n    \n      central Bohemia\n      9357.250000\n    \n    \n      Prague\n      12541.000000\n    \n  \n\n\n\n\n\n#Plotting average salary per regions\ntrace0 = go.Bar (\n    x = region_salary_df.index,\n    y = region_salary_df ['A11'], \n) \ndata = [trace0]\nlayout = go.Layout (title = 'Average salary per region', autosize= False, width= 600, height= 400,\n                    )\nfig = go.Figure (data=data, layout = layout)\npy.iplot (fig, filename = 'Salaries')\n\n\n\n\n\n\n\n\nMen and women almost equally presented among the bank’s customers, 50.74% for men and 49.26% for women.\nMajority of clients are between age of 20 to 60.\nMost of the customers are living in South and North Moravia, on the contrerary South and West Bohemia are the least presented regions. Average salary is nearly evenly distributed among regions except Prague (capital of the country) where average salary is noticeably higher. Apparently invasion into Prague banking market should be reinforced.\n\nFollowing districts are the most attractive: Hl. m. Praha, Brno-mesto, Karvina, Ostrava-mesto, Praha-Vychod, Frydek-Mistek (pretty close to the criteria) for future market presence grow. \n\n\n\n\n\nOverall view on the proportion of issued card products.\n\nCard products distribution among different regions of Czech. Is there any regions where specific card products are more popular than another?\n\nCards issuance trends from 1993 to 1998 overview.\n\n\n# Card products popularity \n\nproduct_count = Counter (cards_df ['type'])\nproduct_counts = pd.DataFrame.from_dict (product_count, orient = 'index')\nproduct_counts.columns = ['Percentage_ratio']\nproduct_counts = product_counts / (product_counts ['Percentage_ratio'].sum ()) * 100\nproduct_counts.plot (kind = 'bar',\n                    title = 'Card products distribution',\n                    width = 0.75,\n                    figsize = (7, 4.8),\n                    subplots = True, \n                    color = [plt.cm.Paired(np.arange(len(region_counts)))]\n                    )\ndisplay (product_count)\n\nCounter({'classic': 659, 'junior': 145, 'gold': 88})\n\n\n\n\n\n\n#merging cards_df and corresponding dispos_df so to find client_id and then from client_id to find corresponding region data\n\ncards_disp_df = cards_df\ncards_disp2_df = cards_disp_df.merge (dispos_df, left_on = 'disp_id', right_on = 'disp_id', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (cards_df.head (n=3))\ndisplay (cards_disp2_df.head (n=3))     \nprint (\"Verifying shape. Before: \" + str (cards_df.shape)+ \" After: \" + str (cards_disp2_df.shape))\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type\n      issued\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type_x\n      issued\n      client_id\n      account_id\n      type_y\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n      9593\n      7753\n      OWNER\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n      588\n      489\n      OWNER\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n      4915\n      4078\n      OWNER\n    \n  \n\n\n\n\nVerifying shape. Before: (892, 4) After: (892, 7)\n\n\n\n#merging cards_disp2_df with clients_dist2_df. as a result I will have a df with card products and corresponding regions info\n#in the same DF\n\ncards_disp3_df = cards_disp2_df\ncards_disp_reg_df = cards_disp3_df.merge (clients_dist2_df, left_on = 'client_id', right_on = 'client_id', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (cards_disp2_df.head (n=3))\ndisplay (cards_disp_reg_df.head (n=3))     \nprint (\"Verifying shape. Before: \" + str (cards_disp2_df.shape)+ \" After: \" + str (cards_disp_reg_df.shape))\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type_x\n      issued\n      client_id\n      account_id\n      type_y\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n      9593\n      7753\n      OWNER\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n      588\n      489\n      OWNER\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n      4915\n      4078\n      OWNER\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type_x\n      issued\n      client_id\n      account_id\n      type_y\n      birth_number\n      district_id\n      birth_date\n      ...\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n      9593\n      7753\n      OWNER\n      685128\n      74\n      1968-01-28\n      ...\n      0\n      1\n      1\n      100.0\n      10673\n      4.75\n      5.44\n      100\n      18782\n      18347\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n      588\n      489\n      OWNER\n      606020\n      61\n      1960-10-20\n      ...\n      5\n      1\n      6\n      53.8\n      8814\n      4.76\n      5.74\n      107\n      2112\n      2059\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n      4915\n      4078\n      OWNER\n      630719\n      40\n      1963-07-19\n      ...\n      6\n      3\n      8\n      85.3\n      9317\n      6.49\n      7.07\n      97\n      6949\n      6872\n    \n  \n\n3 rows × 28 columns\n\n\n\nVerifying shape. Before: (892, 7) After: (892, 28)\n\n\n\n#preparing dataset for plotting of number of products per regions\n\n#grouping by region (\"A3\") and card product ('type_x'), then counting number of cards \nregion_product_df = pd.DataFrame (cards_disp_reg_df.groupby (['A3', 'type_x'], axis = 0) ['type_x'].count ())\nregion_product_df.columns = ['count']\n\n#making columns out of multi-index of A3 and type_x so to make it easier to operate with values\nregion_product_df.reset_index (level= ['type_x', 'A3'], inplace = True)\ndisplay (region_product_df .head (n=5))\n\n\n\n\n\n  \n    \n      \n      A3\n      type_x\n      count\n    \n  \n  \n    \n      0\n      Prague\n      classic\n      96\n    \n    \n      1\n      Prague\n      gold\n      12\n    \n    \n      2\n      Prague\n      junior\n      22\n    \n    \n      3\n      central Bohemia\n      classic\n      88\n    \n    \n      4\n      central Bohemia\n      gold\n      9\n    \n  \n\n\n\n\n\nregions_duplicate = region_product_df.copy () #should be used as copy () otherwise in the loop both df updated\nfor ids, item in enumerate (region_product_df ['A3']):\n    count_sum = regions_duplicate.loc [ids, 'count']\n    div_sum = regions_duplicate [regions_duplicate ['A3'] == item] ['count']. sum ()\n    region_product_df.loc [ids, 'count'] = round (count_sum / (div_sum) *100)\ndisplay (region_product_df .head (n=5))\n\n\n\n\n\n  \n    \n      \n      A3\n      type_x\n      count\n    \n  \n  \n    \n      0\n      Prague\n      classic\n      74.0\n    \n    \n      1\n      Prague\n      gold\n      9.0\n    \n    \n      2\n      Prague\n      junior\n      17.0\n    \n    \n      3\n      central Bohemia\n      classic\n      73.0\n    \n    \n      4\n      central Bohemia\n      gold\n      8.0\n    \n  \n\n\n\n\n\n#plotting percentage of card products per regions \nx = list (region_product_df ['A3'].unique()) #region names\ny =  list (region_product_df [region_product_df ['type_x'] == 'junior'] ['count']) #junior\ny2 = list (region_product_df [region_product_df ['type_x'] == 'classic'] ['count']) #classic\ny3 = list (region_product_df [region_product_df ['type_x'] == 'gold'] ['count']) #gold\njunior = go.Bar(\n    x=x,\n    y=y,\n    text= y,\n    name = 'Junior',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(158,202,225)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\nclassic = go.Bar(\n    x=x,\n    y=y2,\n    text=y2,\n    name = 'Classic',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,100,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ngold = go.Bar(\n    x=x,\n    y=y3,\n    text=y3,\n    name = 'Gold',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,215,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ndata = [junior, classic, gold]\npy.iplot(data, filename='grouped-bar-direct-labels')\n\n\n\n\n\n#preparing dataset for plotting trends of cards issuance per years\n\n#adding a column that will reflect specific year when a card was issued\ncards_disp2_df ['issue_year'] = cards_disp2_df ['issued']\n\ncards_disp2_df ['issue_year'] = cards_disp2_df ['issue_year'].apply (date_parsing)\ncards_disp2_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      card_id\n      disp_id\n      type_x\n      issued\n      client_id\n      account_id\n      type_y\n      issue_year\n    \n  \n  \n    \n      0\n      1005\n      9285\n      classic\n      931107 00:00:00\n      9593\n      7753\n      OWNER\n      1993\n    \n    \n      1\n      104\n      588\n      classic\n      940119 00:00:00\n      588\n      489\n      OWNER\n      1994\n    \n    \n      2\n      747\n      4915\n      classic\n      940205 00:00:00\n      4915\n      4078\n      OWNER\n      1994\n    \n  \n\n\n\n\n\n#grouping by issue_year and card product ('type_x'), then counting number of cards \nyear_product_df = pd.DataFrame (cards_disp2_df.groupby (['issue_year', 'type_x'], axis = 0) ['type_x'].count ())\n\n#naming column as 'count' \nyear_product_df.columns = ['count']\n\n#making columns out of multi-index of A3 and type_x so to make it easier to operate with values\nyear_product_df.reset_index (level= ['type_x', 'issue_year'], inplace = True)\ndisplay (year_product_df .head (n=5))\n\n\n\n\n\n  \n    \n      \n      issue_year\n      type_x\n      count\n    \n  \n  \n    \n      0\n      1993\n      classic\n      1\n    \n    \n      1\n      1994\n      classic\n      17\n    \n    \n      2\n      1994\n      junior\n      4\n    \n    \n      3\n      1995\n      classic\n      42\n    \n    \n      4\n      1995\n      gold\n      4\n    \n  \n\n\n\n\n\n#no values for junior and gold products in 1993 and no values for gold cards in 1994\n#adding them as zeroes\n\nlist_of_zer = [pd.Series ([1993, 'junior', 0], index = year_product_df.columns),\n               pd.Series ([1993, 'gold', 0], index = year_product_df.columns),\n               pd.Series ([1994, 'gold', 0], index = year_product_df.columns),\n                ]\nyear_product_df = year_product_df.append (list_of_zer, ignore_index = True)\nyear_product_df.sort_values (['issue_year', 'type_x'], inplace= True)\nyear_product_df.reset_index (inplace = True, drop = True) #making index start from 0 again\ndisplay (year_product_df .head (n=5))\n\n\n\n\n\n  \n    \n      \n      issue_year\n      type_x\n      count\n    \n  \n  \n    \n      0\n      1993\n      classic\n      1\n    \n    \n      1\n      1993\n      gold\n      0\n    \n    \n      2\n      1993\n      junior\n      0\n    \n    \n      3\n      1994\n      classic\n      17\n    \n    \n      4\n      1994\n      gold\n      0\n    \n  \n\n\n\n\n\n#plotting number of card products per years \nx = list (year_product_df ['issue_year'].unique()) #years \ny =  list (year_product_df [year_product_df ['type_x'] == 'junior'] ['count']) #junior\ny2 = list (year_product_df [year_product_df ['type_x'] == 'classic'] ['count']) #classic\ny3 = list (year_product_df [year_product_df ['type_x'] == 'gold'] ['count']) #gold\n\njunior = go.Bar(\n    x=x,\n    y=y,\n    text= y,\n    name = 'Junior',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(158,202,225)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\nclassic = go.Bar(\n    x=x,\n    y=y2,\n    text=y2,\n    name = 'Classic',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,100,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ngold = go.Bar(\n    x=x,\n    y=y3,\n    text=y3,\n    name = 'Gold',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,215,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ndata = [junior, classic, gold]\npy.iplot(data, filename='grouped-bar-direct-labels')\n\n\n\n\n\n#making a new dataset that will contain percentage of each card product per year \n\nyear_duplicate = year_product_df.copy () #should be used as copy () otherwise in the loop both df updated\nfor ids, item in enumerate (year_product_df ['issue_year']):\n    count_sum = year_duplicate.loc [ids, 'count']\n    div_sum = year_duplicate [year_duplicate ['issue_year'] == item] ['count']. sum ()\n    year_product_df.loc [ids, 'count'] = round (count_sum / (div_sum) *100)\n      \ndisplay (year_product_df .head (n=5))\n\n\n\n\n\n  \n    \n      \n      issue_year\n      type_x\n      count\n    \n  \n  \n    \n      0\n      1993\n      classic\n      100.0\n    \n    \n      1\n      1993\n      gold\n      0.0\n    \n    \n      2\n      1993\n      junior\n      0.0\n    \n    \n      3\n      1994\n      classic\n      81.0\n    \n    \n      4\n      1994\n      gold\n      0.0\n    \n  \n\n\n\n\n\n#plotting percentafe of card products per years \nx = list (year_product_df ['issue_year'].unique()) #years \ny =  list (year_product_df [year_product_df ['type_x'] == 'junior'] ['count']) #junior\ny2 = list (year_product_df [year_product_df ['type_x'] == 'classic'] ['count']) #classic\ny3 = list (year_product_df [year_product_df ['type_x'] == 'gold'] ['count']) #gold\n\njunior = go.Bar(\n    x=x,\n    y=y,\n    text= y,\n    name = 'Junior',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(158,202,225)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\nclassic = go.Bar(\n    x=x,\n    y=y2,\n    text=y2,\n    name = 'Classic',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,100,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ngold = go.Bar(\n    x=x,\n    y=y3,\n    text=y3,\n    name = 'Gold',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,215,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ndata = [junior, classic, gold]\npy.iplot(data, filename='grouped-bar-direct-labels')\n\n\n\n\n\n\n\n\nOverall view on the proportion of issued card products: 74% of issued cards are classic cards, 16% - junior cards and 10% - gold.\n\nCard products distribution among different regions of Czech. Is there any regions where specific card products are more popular than another? Majority of cards in all regions are “classic” - more than 70%, junior cards prevail on gold in all regions except for North Bohemia.\n\nCards issuance trends from 1993 to 1998 overview. Number of issued cards growing from year to year. Classic cards remain the most popular among customers. Second place occupied by junior cards, gold cards on the third place, except for 1997 where number of both produced products is equal.\n\n\n\n\n\nDoes a loan with higher monthly payment generally tend to be unpaid or overdue?\nDoes longer duration of a loan pretend to protect against overdues in most of the cases?\n\nIs there direct dependence between higher amount of a loan and higher probability the loan to be delinquent?\nLoans status distribution within districts. Are there branches where credit exposure of the bank is not duly managed?\n\n\n#preparing dataset and replacing A, B, C, D with description text\nloans2_df = loans_df.copy ()\nloans2_df ['status_desc'] = loans2_df ['status']\n\ndict1 =  {'A':'Contract finished, no problem', \n      'B':'Contract finised, loan was not paid',\n      'C':'Runing contract, OK so far',\n      'D':'Runing contract, client in debt'\n     }\nloans2_df.status_desc = loans2_df.status_desc.replace (dict1)\n\nloans2_df ['status_numeric'] = loans2_df ['status']\n\n#encoding bad loans as 1 and good ones as -1 \ndict2 =  {'A':-1, \n      'B':1,\n      'C':-1,\n      'D':1\n     }\nloans2_df.status_numeric = loans2_df.status_numeric.replace (dict2)\ndisplay (loans2_df.head (n=3))\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n    \n  \n\n\n\n\n\n#correlation between loan status and monthly payments\n#display (loans2_df.groupby (['status_desc']).mean () ['payments'].sort_values ())\n\n\n#correlation between loan status and duration of a loan \n#loans2_df.groupby (['status_desc']).mean () ['duration'].sort_values ()\n\n\n#correlation between loan status and loan's amount \n#loans2_df.groupby (['status_desc']).mean () ['amount'].sort_values ()\n\n\n#correlation matrix\nloans3_df = loans2_df.copy ()\nloans3_df.drop (['loan_id', 'account_id'], axis =1, inplace = True)\nsns.heatmap (loans3_df.corr (), annot = True, fmt=\".2f\");\n\n\n\n\n\n# enriching dataframe with accounts_df \n\nloans_acc_df = loans2_df.copy ()\nloans_acc_df = loans_acc_df.merge (accounts_df, left_on = 'account_id', right_on = 'account_id', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (loans2_df.head (n=3))\ndisplay (loans_acc_df.head (n=3))\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date_x\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n      district_id\n      frequency\n      date_y\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n      30\n      POPLATEK TYDNE\n      1993-03-22\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n      46\n      POPLATEK MESICNE\n      1993-02-13\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n      45\n      POPLATEK MESICNE\n      1993-02-08\n    \n  \n\n\n\n\n\n# enriching dataframe with district_df data\n\nloans_acc_distr_df = loans_acc_df.copy ()\nloans_acc_distr_df = loans_acc_distr_df.merge (district_df, left_on = 'district_id', right_on = 'A1', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (loans_acc_df.head (n=3))\ndisplay (loans_acc_distr_df.head (n=3))\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date_x\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n      district_id\n      frequency\n      date_y\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n      30\n      POPLATEK TYDNE\n      1993-03-22\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n      46\n      POPLATEK MESICNE\n      1993-02-13\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n      45\n      POPLATEK MESICNE\n      1993-02-08\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date_x\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n      district_id\n      ...\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n      30\n      ...\n      8\n      2\n      10\n      81.8\n      9650\n      3.38\n      3.67\n      100\n      2985\n      2804\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n      46\n      ...\n      7\n      3\n      10\n      73.5\n      8369\n      1.79\n      2.31\n      117\n      2854\n      2618\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n      45\n      ...\n      6\n      1\n      5\n      53.5\n      8390\n      2.28\n      2.89\n      132\n      2080\n      2122\n    \n  \n\n3 rows × 28 columns\n\n\n\n\n#number of duplicated accounts in loans_acc_df. I was checking if several loans can be tied to the same account ? \ntest_df = pd.DataFrame (loans_acc_df ['account_id'].duplicated ())\nprint (test_df [test_df ['account_id'] == True])\n\nEmpty DataFrame\nColumns: [account_id]\nIndex: []\n\n\nThe answer is “no” multiple loans cannot be tied to the same account\n\n# enriching disposition dataframe with clients_df then I will have a df which will contain loan, district, \n#disposition and client info\n\ndispos_client_df = dispos_df.copy ()\ndispos_client_df = dispos_client_df.merge (clients_df, left_on = 'client_id', right_on = 'client_id', \n                                           how = 'left', validate = 'many_to_one') \ndisplay (dispos_df.head (n=3))\ndisplay (dispos_client_df.head (n=3))   \n\n\n\n\n\n  \n    \n      \n      disp_id\n      client_id\n      account_id\n      type\n    \n  \n  \n    \n      0\n      1\n      1\n      1\n      OWNER\n    \n    \n      1\n      2\n      2\n      2\n      OWNER\n    \n    \n      2\n      3\n      3\n      2\n      DISPONENT\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      disp_id\n      client_id\n      account_id\n      type\n      birth_number\n      district_id\n      birth_date\n      gender\n      age\n    \n  \n  \n    \n      0\n      1\n      1\n      1\n      OWNER\n      706213\n      18\n      1970-12-13\n      0.0\n      28\n    \n    \n      1\n      2\n      2\n      2\n      OWNER\n      450204\n      1\n      1945-02-04\n      1.0\n      53\n    \n    \n      2\n      3\n      3\n      2\n      DISPONENT\n      406009\n      1\n      1940-10-09\n      0.0\n      58\n    \n  \n\n\n\n\n\n#number of duplicated accounts in dispos_client_df. checking if the same account can be tied to several clients\ntest2_df = pd.DataFrame (dispos_client_df ['account_id'].duplicated ())\n\nprint (dispos_client_df.shape) #number of disposition - clients \nprint (test2_df [test2_df ['account_id'] == True].shape) #number of duplicates\n\nprint ('this means that same accounts can be owned by different clients where one of them can be owner and the second one disponent') \nprint ('Cannot merge enrich loans_acc_distr_df with some customer related data and see if some personal factors affects loan status as same account can be owned by different persons')\n\n(5369, 9)\n(869, 1)\nthis means that same accounts can be owned by different clients where one of them can be owner and the second one disponent\nCannot merge enrich loans_acc_distr_df with some customer related data and see if some personal factors affects loan status as same account can be owned by different persons\n\n\n\n#heatmap for correlation between districts and loan statuses\nloans_acc_distr_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      loan_id\n      account_id\n      date_x\n      amount\n      duration\n      payments\n      status\n      status_desc\n      status_numeric\n      district_id\n      ...\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      5314\n      1787\n      1993-07-05\n      96396\n      12\n      8033.0\n      B\n      Contract finised, loan was not paid\n      1\n      30\n      ...\n      8\n      2\n      10\n      81.8\n      9650\n      3.38\n      3.67\n      100\n      2985\n      2804\n    \n    \n      1\n      5316\n      1801\n      1993-07-11\n      165960\n      36\n      4610.0\n      A\n      Contract finished, no problem\n      -1\n      46\n      ...\n      7\n      3\n      10\n      73.5\n      8369\n      1.79\n      2.31\n      117\n      2854\n      2618\n    \n    \n      2\n      6863\n      9188\n      1993-07-28\n      127080\n      60\n      2118.0\n      A\n      Contract finished, no problem\n      -1\n      45\n      ...\n      6\n      1\n      5\n      53.5\n      8390\n      2.28\n      2.89\n      132\n      2080\n      2122\n    \n  \n\n3 rows × 28 columns\n\n\n\n\n## Using the pandas.groupby() method to produce a pivot table:\n\ndist_loans_df = loans_acc_distr_df.groupby(by=['A2']).status_desc.value_counts().sort_index()\ndist_loans_df.head (n=3)\n\nA2       status_desc                  \nBenesov  Contract finished, no problem    1\n         Runing contract, OK so far       5\nBeroun   Contract finished, no problem    1\nName: status_desc, dtype: int64\n\n\n\n## Manipulating the data:\ndist_loans_df = dist_loans_df.unstack()  #Converting the groupby object into a dataset\n#dist_loans_df.head (n=10)\ndist_loans_df.fillna(value=0.0, inplace=True)  #Replacing NaN values by zero\ndist_loans_df = df_row_normalize(dist_loans_df)  #Normalizing its values by the total of each row\n## Converting the normalized float values to percentual int values:\ndist_loans_df = (dist_loans_df*100).astype(float).applymap('{:,.2f}'.format)#\ndist_loans_df.head (n=5)\n\n\n\n\n\n  \n    \n      status_desc\n      Contract finised, loan was not paid\n      Contract finished, no problem\n      Runing contract, OK so far\n      Runing contract, client in debt\n    \n    \n      A2\n      \n      \n      \n      \n    \n  \n  \n    \n      Benesov\n      0.00\n      16.67\n      83.33\n      0.00\n    \n    \n      Beroun\n      0.00\n      16.67\n      50.00\n      33.33\n    \n    \n      Blansko\n      0.00\n      42.86\n      42.86\n      14.29\n    \n    \n      Breclav\n      14.29\n      14.29\n      71.43\n      0.00\n    \n    \n      Brno - mesto\n      8.33\n      16.67\n      62.50\n      12.50\n    \n  \n\n\n\n\n\n#converting df columns dtype into float16 so to make it visible in the heatmap. \ndist_loans_df = dist_loans_df.astype(np.float16)\ndist_loans_df.dtypes\n\nstatus_desc\nContract finised, loan was not paid    float16\nContract finished, no problem          float16\nRuning contract, OK so far             float16\nRuning contract, client in debt        float16\ndtype: object\n\n\n\n# Drawing a heatmap with the numeric values in each cell\nfig3, ax = plt.subplots(figsize=(10, 25))\nfig3.subplots_adjust(top=.965)\nplt.suptitle('Relative loans status distributed by districts', fontsize=14, fontweight='bold')\n\ncbar_kws = {'orientation':\"horizontal\", 'pad':0.13, 'aspect':50}\nsns.heatmap(dist_loans_df, annot=True, fmt='.2f', linewidths=.3, cmap='RdPu', ax=ax, cbar_kws=cbar_kws );\n\n\n\n\n\n\n\n\nGenerally higher monthly payments tied with unpaid or overdue loans.\nFrom the correlation matrix we can conclude that longer duration slightly increases probability for a loan to be delinquent.\nWe can see that higher amount of monthly payment correlated with overdue/unpaid debts at the same time lower amount in most of the cases stands for diligent case.\n\nCases in branches of following districts should be investigated for subject of potential scam or not duly managed credit risks: Strakonice, Sokolov, Opava, Kutna Hora, Klatovy, Domazlice, Bruntal, Beroun. In those districts number of problematic debts is more than 30%.\n\n\n\n\n\nTransaction types distribution in the dataset\n\nPossible trends and patterns in transactions distribution within given period (1993-1998). Is there any type of trx that was less popular and it’s number growed within time?\n\nCloser look into funds transfer from and to another banks. Is the overall balance positive? Are there any trends with the balance in the given period?\n\n\n#take a look to the subset where operation values are missing\n\ntrans_opermis_df = trans_df [trans_df ['operation'].isnull ()] [trans_df.columns]\ntrans_opermis_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n    \n  \n  \n    \n      137\n      3591421\n      1844\n      1993-01-31\n      PRIJEM\n      NaN\n      12.6\n      3754.6\n      UROK\n      NaN\n      NaN\n    \n    \n      138\n      3617490\n      2632\n      1993-01-31\n      PRIJEM\n      NaN\n      47.5\n      15411.5\n      UROK\n      NaN\n      NaN\n    \n    \n      139\n      3579543\n      1493\n      1993-01-31\n      PRIJEM\n      NaN\n      13.3\n      5222.3\n      UROK\n      NaN\n      NaN\n    \n  \n\n\n\n\n\n#interpretation why it is missing\n\ntrans_opermis_df.groupby ('type', axis =0).count ()\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n    \n    \n      type\n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      PRIJEM\n      183114\n      183114\n      183114\n      0\n      183114\n      183114\n      183114\n      0\n      0\n    \n  \n\n\n\n\n\ntrans_opermis_df.groupby ('k_symbol', axis =0).count ()\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      bank\n      account\n    \n    \n      k_symbol\n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      UROK\n      183114\n      183114\n      183114\n      183114\n      0\n      183114\n      183114\n      0\n      0\n    \n  \n\n\n\n\nIt appeared that the only possible value in k_symbol for the subset is “UROK” which stands for “interest credited”. We can conclude that operation values are missing since those are transactions “interest credited”, it cannot be filled with any operation type like case withdrawal, remittance or anything else. We can substitute missing values in “operation” with new value “interest_credit”.\n\n#substituting missing values in \"operation\"\ntrans_df ['operation'].fillna ('INTEREST_CREDIT', inplace = True)\n\n#filling all missing values as np.NaN\ntrans_df.fillna (np.NaN, inplace = True)\n\ntrans_df.isnull ().sum ()\n\ntrans_id           0\naccount_id         0\ndate               0\ntype               0\noperation          0\namount             0\nbalance            0\nk_symbol      481881\nbank          782812\naccount       760931\ndtype: int64\n\n\n\n#transactions popularity for the whole reported period \n\ntrans_count = Counter (trans_df ['operation'])\n\ntrans_counts = pd.DataFrame.from_dict (trans_count, orient = 'index')\ntrans_counts.columns = ['Percentage_ratio']\ntrans_counts = trans_counts / (trans_counts ['Percentage_ratio'].sum ()) * 100\n\n#renaming indices \ntrans_counts.rename (index = {'VKLAD':'Credit in cash', 'PREVOD Z UCTU':'Collection from another bank', 'VYBER':'Withdrawal in cash',\n                             'INTEREST_CREDIT':'Interest credit', 'PREVOD NA UCET':'Remittance to another bank', \n                             'VYBER KARTOU':'Withdrawal from credit card'}, inplace = True)#, , , \n                            #'Remittance to another bank', ], inplace = True)\n\ntrans_counts.plot (kind = 'bar',\n                    title = 'Transaction types distribution',\n                    width = 0.75,\n                    figsize = (8, 5.8),\n                    subplots = True, \n                    color = [plt.cm.Paired(np.arange(len(region_counts)))]\n                    )\ntrans_counts #pd.DataFrame (list(trans_count.items ())) #/trans_df.shape [0]*100\n\n\n\n\n\n  \n    \n      \n      Percentage_ratio\n    \n  \n  \n    \n      Credit in cash\n      14.838591\n    \n    \n      Collection from another bank\n      6.174833\n    \n    \n      Withdrawal in cash\n      41.172940\n    \n    \n      Interest credit\n      17.335088\n    \n    \n      Remittance to another bank\n      19.717794\n    \n    \n      Withdrawal from credit card\n      0.760754\n    \n  \n\n\n\n\n\n\n\n\n#adding a column indicating a year when a transaction was performed \ntrans_df ['tran_year'] = trans_df ['date']\ntrans_df ['tran_year'] = trans_df ['tran_year'].apply (year_extract)\n    \ntrans_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n    \n  \n  \n    \n      0\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n    \n      1\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n    \n      2\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n  \n\n\n\n\n\n#grouping by tran_year and operation, then counting number of transactions  \nyear_trantype_df = pd.DataFrame (trans_df.groupby (['tran_year', 'operation'], axis = 0) ['operation'].count ())\n\n#naming column as 'count' \nyear_trantype_df.columns = ['count']\n\n#making columns out of multi-index of tran_year and operation so to make it easier to operate with values\nyear_trantype_df.reset_index (level= ['operation', 'tran_year'], inplace = True)\n\ndisplay (year_trantype_df .head (n=3))\n\n\n\n\n\n  \n    \n      \n      tran_year\n      operation\n      count\n    \n  \n  \n    \n      0\n      1993\n      INTEREST_CREDIT\n      6065\n    \n    \n      1\n      1993\n      PREVOD NA UCET\n      3231\n    \n    \n      2\n      1993\n      PREVOD Z UCTU\n      2462\n    \n  \n\n\n\n\n\n#no values for VYBER KARTOU in 1993 \n#adding as zero\n\nlist_of_zer1 = [pd.Series ([1993, 'VYBER KARTOU', 0], index = year_trantype_df.columns)]\nyear_trantype_df = year_trantype_df.append (list_of_zer1, ignore_index = True)\n\nyear_trantype_df.sort_values (['tran_year', 'operation'], inplace= True)\nyear_trantype_df.reset_index (inplace = True, drop = True) #making index start from 0 again\ndisplay (year_trantype_df .head (n=6))\n\n\n\n\n\n  \n    \n      \n      tran_year\n      operation\n      count\n    \n  \n  \n    \n      0\n      1993\n      INTEREST_CREDIT\n      6065\n    \n    \n      1\n      1993\n      PREVOD NA UCET\n      3231\n    \n    \n      2\n      1993\n      PREVOD Z UCTU\n      2462\n    \n    \n      3\n      1993\n      VKLAD\n      6685\n    \n    \n      4\n      1993\n      VYBER\n      9762\n    \n    \n      5\n      1993\n      VYBER KARTOU\n      0\n    \n  \n\n\n\n\n\n#plotting number of transactions per year \n\nx = list (year_trantype_df ['tran_year'].unique()) #years \ny =  list (year_trantype_df [year_trantype_df ['operation'] == 'INTEREST_CREDIT'] ['count']) \ny2 = list (year_trantype_df [year_trantype_df ['operation'] == 'PREVOD NA UCET'] ['count']) \ny3 = list (year_trantype_df [year_trantype_df ['operation'] == 'PREVOD Z UCTU'] ['count']) \ny4 = list (year_trantype_df [year_trantype_df ['operation'] == 'VKLAD'] ['count']) \ny5 = list (year_trantype_df [year_trantype_df ['operation'] == 'VYBER'] ['count']) \ny6 = list (year_trantype_df [year_trantype_df ['operation'] == 'VYBER KARTOU'] ['count']) \n\nbar1 = go.Bar(\n    x=x,\n    y=y,\n    text= y,\n    name = 'Interest credit',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(158,202,225)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\nbar2 = go.Bar(\n    x=x,\n    y=y2,\n    text=y2,\n    name = 'Remittance to another bank',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,100,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\nbar3 = go.Bar(\n    x=x,\n    y=y3,\n    text=y3,\n    name = 'Collection from another bank',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(128,0,128)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\nbar4 = go.Bar(\n    x=x,\n    y=y4,\n    text=y4,\n    name = 'Credit in cash',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,139,139)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\nbar5 = go.Bar(\n    x=x,\n    y=y5,\n    text=y5,\n    name = 'Withdrawal in cash',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,215,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\nbar6 = go.Bar(\n    x=x,\n    y=y6,\n    text=y6,\n    name = 'Withdrawal from credit card',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,0,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\n\ndata = [bar1, bar2, bar3, bar4, bar5, bar6]\n\npy.iplot(data, filename='grouped-bar-direct-labels')\n\n\n\n\n\n#investigating transactions marked as \"collection from another bank\" \n\ntrans_col_df = trans_df [trans_df ['operation'] == 'PREVOD Z UCTU']\n\n#unique values in the column k_symbol which will describe possible reason for collection\ntrans_col_df ['k_symbol'].unique ()\n\narray(['DUCHOD', nan], dtype=object)\n\n\n\n#checking proportion of each possible value: DUCHOD ( old-age pension) and NaNs\npd.DataFrame(Counter (trans_col_df ['k_symbol']), index = [0]).transpose () / trans_col_df.shape [0] * 100\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      DUCHOD\n      46.512127\n    \n    \n      NaN\n      53.487873\n    \n  \n\n\n\n\nFrom the above we can conclude that 46.5% of “collection from another bank” transactions stands for old-age pension and 53.5% transactions were not specifically identified which may related to funds transfers between clients.\n\ntrans_col_df [trans_col_df ['k_symbol'] == 'DUCHOD'] ['amount'].sum ()\n\n167472118.0\n\n\n\ntrans_col_df [trans_col_df ['k_symbol'] != 'DUCHOD'] ['amount'].sum ()\n\n614007835.0\n\n\n\n#investigating transactions marked as \"remittance to another bank\"\ntrans_rem_df = trans_df [trans_df ['operation'] == 'PREVOD NA UCET']\n\n#unique values in the column k_symbol which will describe possible reason for collection\ntrans_rem_df ['k_symbol'].unique ()\n\narray(['SIPO', ' ', 'POJISTNE', nan, 'UVER'], dtype=object)\n\n\n\n#filling spaces in k_symbol with NaN\ntrans_rem_df = trans_rem_df.replace(r'^\\s*$', np.nan, regex=True)\n\n\n#verifying result \ntrans_rem_df ['k_symbol'].unique ()\n\narray(['SIPO', nan, 'POJISTNE', 'UVER'], dtype=object)\n\n\n\n#checking proportion of each possible value for remittance transactions\npd.DataFrame(Counter (trans_rem_df ['k_symbol']), index = [0]).transpose () / trans_rem_df.shape [0] * 100\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      SIPO\n      55.335289\n    \n    \n      NaN\n      29.273633\n    \n    \n      POJISTNE\n      8.871103\n    \n    \n      UVER\n      6.519975\n    \n  \n\n\n\n\nFrom the above we see that majority (55.3%) of remittance transactions related to household payments, on the second place (29.3%) payment reason unknown, on the third (8.9%) - insurance payments, on the last place (6.5%) - loan payments.\n\n#verifying positive/negative balance between collection from another banks and remittance to another banks\ntrans_colrem_df = trans_col_df.append (trans_rem_df)\n\n#overall balance of incoming (PREVOD Z UCTU) and outgoing (PREVOD NA UCET)\ndisplay (pd.DataFrame (trans_colrem_df.groupby (['operation']).sum () ['amount'].sort_values ()))\n\n#proportion \ndisplay (pd.DataFrame (trans_colrem_df.groupby (['operation']).sum () ['amount'].sort_values ())/trans_colrem_df ['amount'].sum () *100)\n\n\n\n\n\n  \n    \n      \n      amount\n    \n    \n      operation\n      \n    \n  \n  \n    \n      PREVOD NA UCET\n      672637786.3\n    \n    \n      PREVOD Z UCTU\n      781479953.0\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      amount\n    \n    \n      operation\n      \n    \n  \n  \n    \n      PREVOD NA UCET\n      46.25745\n    \n    \n      PREVOD Z UCTU\n      53.74255\n    \n  \n\n\n\n\n\n#mean of remittance and collection \ndisplay (pd.DataFrame (trans_colrem_df.groupby (['operation']).mean () ['amount'].sort_values ()))\n\n\n\n\n\n  \n    \n      \n      amount\n    \n    \n      operation\n      \n    \n  \n  \n    \n      PREVOD NA UCET\n      3229.441607\n    \n    \n      PREVOD Z UCTU\n      11981.111106\n    \n  \n\n\n\n\nFrom 1993 to 1998 overall balance is positive: received amount is bigger for 7.5% comparing to outgoing.\n\n#now let's take a look if there is any trend from 1993 to 1998 in the amounts for remittance and collection\nyear_transfer_df = pd.DataFrame (trans_colrem_df.groupby (['operation','tran_year'], axis = 0) ['amount'] .sum ().sort_values ())\n\n#naming column as 'sum' \nyear_transfer_df.columns = ['sum']\n\n#making columns out of multi-index so to make it easier to operate with values\nyear_transfer_df.reset_index (inplace = True)\n\n#renaming values in operation so to have better visibility\ndict11 =  {'PREVOD NA UCET':'Remittance to another bank', \n      'PREVOD Z UCTU':'Collection from another bank'\n     }\nyear_transfer_df.operation = year_transfer_df.operation.replace (dict11)\n\ndisplay (year_transfer_df .head (n=30))\n\n\n\n\n\n  \n    \n      \n      operation\n      tran_year\n      sum\n    \n  \n  \n    \n      0\n      Remittance to another bank\n      1993\n      10159410.7\n    \n    \n      1\n      Collection from another bank\n      1993\n      29809129.0\n    \n    \n      2\n      Remittance to another bank\n      1994\n      53841549.1\n    \n    \n      3\n      Collection from another bank\n      1994\n      68925764.0\n    \n    \n      4\n      Remittance to another bank\n      1995\n      81845324.4\n    \n    \n      5\n      Collection from another bank\n      1995\n      99242619.0\n    \n    \n      6\n      Remittance to another bank\n      1996\n      119563522.2\n    \n    \n      7\n      Collection from another bank\n      1996\n      146015899.0\n    \n    \n      8\n      Remittance to another bank\n      1997\n      182443823.2\n    \n    \n      9\n      Collection from another bank\n      1997\n      207339926.0\n    \n    \n      10\n      Remittance to another bank\n      1998\n      224784156.7\n    \n    \n      11\n      Collection from another bank\n      1998\n      230146616.0\n    \n  \n\n\n\n\n\n#plotting sum of remittance and collection per years \nx = list (year_transfer_df ['tran_year'].unique()) #years \ny =  list (year_transfer_df [year_transfer_df ['operation'] == 'Remittance to another bank'] ['sum']) \ny2 = list (year_transfer_df [year_transfer_df ['operation'] == 'Collection from another bank'] ['sum']) \n\nbar2 = go.Bar(\n    x=x,\n    y=y,\n    text=y,\n    name = 'Remittance to another bank',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(0,100,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\nbar5 = go.Bar(\n    x=x,\n    y=y2,\n    text=y2,\n    name = 'Collection from another bank',\n    textposition = 'auto',\n    marker=dict(\n        color='rgb(255,215,0)',\n        line=dict(\n            color='rgb(8,48,107)',\n            width=1.5),\n        ),\n    opacity=0.6\n)\ndata = [bar2, bar5]\npy.iplot(data, filename='grouped-bar-direct-labels')\n\n\n\n\n\n#a dataframe for plotting remittance and colletion by months distribution\ntrans_remcol_df = trans_colrem_df.copy ()\n\n#columns with amounts that affects balance positively - collection from another banks \ntrans_remcol_df = trans_remcol_df.assign (pos_sum = np.nan)\n\n#columns with amounts that affects balance negatively - remittance to another banks\ntrans_remcol_df = trans_remcol_df.assign (neg_sum = np.nan)\n\n#filling columns pos_sum and neg_sum based on operation type. pos_sum stands for inflows\ntrans_remcol_df.pos_sum = trans_remcol_df.amount.where (trans_remcol_df.operation == 'PREVOD Z UCTU', trans_remcol_df.pos_sum)\n\n#neg_sum stands for outflows\ntrans_remcol_df.neg_sum = trans_remcol_df.amount.where (trans_remcol_df.operation == 'PREVOD NA UCET', trans_remcol_df.neg_sum )\n\ndisplay (trans_remcol_df.head (n=3))\ntrans_remcol_df [trans_remcol_df ['operation'] == 'PREVOD Z UCTU'].tail (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      pos_sum\n      neg_sum\n    \n  \n  \n    \n      15\n      637742\n      2177\n      1993-01-05\n      PRIJEM\n      PREVOD Z UCTU\n      5123.0\n      5923.0\n      DUCHOD\n      YZ\n      62457513.0\n      1993\n      5123.0\n      NaN\n    \n    \n      17\n      232961\n      793\n      1993-01-05\n      PRIJEM\n      PREVOD Z UCTU\n      3401.0\n      4201.0\n      NaN\n      IJ\n      6149286.0\n      1993\n      3401.0\n      NaN\n    \n    \n      21\n      542216\n      1844\n      1993-01-07\n      PRIJEM\n      PREVOD Z UCTU\n      3242.0\n      3742.0\n      NaN\n      ST\n      42988401.0\n      1993\n      3242.0\n      NaN\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      pos_sum\n      neg_sum\n    \n  \n  \n    \n      1047122\n      546460\n      1860\n      1998-12-14\n      PRIJEM\n      PREVOD Z UCTU\n      3255.0\n      20916.3\n      NaN\n      MN\n      61854898.0\n      1998\n      3255.0\n      NaN\n    \n    \n      1047127\n      605757\n      2062\n      1998-12-14\n      PRIJEM\n      PREVOD Z UCTU\n      64642.0\n      97552.6\n      NaN\n      EF\n      10179949.0\n      1998\n      64642.0\n      NaN\n    \n    \n      1047137\n      519257\n      1773\n      1998-12-14\n      PRIJEM\n      PREVOD Z UCTU\n      4316.0\n      17215.9\n      DUCHOD\n      CD\n      77385341.0\n      1998\n      4316.0\n      NaN\n    \n  \n\n\n\n\n\n#we need a pandas.DateTimeIndex for resampling\ntrans_remcol_df.set_index (trans_remcol_df ['date'], inplace = True)\ntrans_remcol_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      pos_sum\n      neg_sum\n    \n    \n      date\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1993-01-05\n      637742\n      2177\n      1993-01-05\n      PRIJEM\n      PREVOD Z UCTU\n      5123.0\n      5923.0\n      DUCHOD\n      YZ\n      62457513.0\n      1993\n      5123.0\n      NaN\n    \n    \n      1993-01-05\n      232961\n      793\n      1993-01-05\n      PRIJEM\n      PREVOD Z UCTU\n      3401.0\n      4201.0\n      NaN\n      IJ\n      6149286.0\n      1993\n      3401.0\n      NaN\n    \n    \n      1993-01-07\n      542216\n      1844\n      1993-01-07\n      PRIJEM\n      PREVOD Z UCTU\n      3242.0\n      3742.0\n      NaN\n      ST\n      42988401.0\n      1993\n      3242.0\n      NaN\n    \n  \n\n\n\n\n\n#plotting results with aggregation on the level of years\ninflows = trans_remcol_df['pos_sum'].resample('Y').sum ()\noutflows = trans_remcol_df['neg_sum'].resample('Y').sum ()\n\nplt.style.use('fivethirtyeight')\nx = outflows.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (inflows / 1000000) \ny2 = list (outflows / 1000000)\n\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Collection')\nax.plot(x, y2, label = 'Remittance' )#, figsize = (8,8))\nax.set_title(\"Collection from and remittance to another banks (years)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#plotting results with aggregation on the level of months\ninflows = trans_remcol_df['pos_sum'].resample('M').sum ()\noutflows = trans_remcol_df['neg_sum'].resample('M').sum ()\n\nplt.style.use('fivethirtyeight')\nx = outflows.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (inflows / 1000000) \ny2 = list (outflows / 1000000)\n\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Collection')\nax.plot(x, y2, label = 'Remittance' )#, figsize = (8,8))\nax.set_title(\"Collection from and remittance to another banks (months)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#complementing trans_df with account data and district data\ntrans_acc_df = trans_df.copy ()\ntrans_acc_df = trans_acc_df.merge (accounts_df, left_on = 'account_id', right_on = 'account_id', \n                                           how = 'left', validate = 'many_to_one') \ntrans_acc_dist_df = trans_acc_df.merge (district_df, left_on = 'district_id', right_on = 'A1', \n                                           how = 'left', validate = 'many_to_one')\ndisplay (trans_df.head (n=3))\ndisplay (trans_acc_df.head (n=3)) \ndisplay (trans_acc_dist_df.head (n=3))\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n    \n  \n  \n    \n      0\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n    \n      1\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n    \n      2\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      1993\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date_x\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      district_id\n      frequency\n      date_y\n    \n  \n  \n    \n      0\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      1993\n      16\n      POPLATEK MESICNE\n      1993-01-01\n    \n    \n      1\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      1993\n      55\n      POPLATEK MESICNE\n      1993-01-01\n    \n    \n      2\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      1993\n      55\n      POPLATEK MESICNE\n      1993-01-01\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date_x\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      ...\n      A7\n      A8\n      A9\n      A10\n      A11\n      A12\n      A13\n      A14\n      A15\n      A16\n    \n  \n  \n    \n      0\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      ...\n      10\n      1\n      8\n      56.9\n      8427\n      1.12\n      1.54\n      107\n      1874\n      1913\n    \n    \n      1\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      ...\n      18\n      0\n      9\n      33.9\n      8743\n      1.88\n      2.43\n      111\n      3659\n      3894\n    \n    \n      2\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      ...\n      18\n      0\n      9\n      33.9\n      8743\n      1.88\n      2.43\n      111\n      3659\n      3894\n    \n  \n\n3 rows × 30 columns\n\n\n\n\ntrans_bal_df = trans_df.copy ()\n\n#column with amounts that affects balance positively \ntrans_bal_df = trans_bal_df.assign (pos_sum = np.nan)\n\n#column with amounts that affects balance negatively \ntrans_bal_df = trans_bal_df.assign (neg_sum = np.nan)\n\n#filling columns pos_sum and neg_sum based on operation type. pos_sum stands for inflows\ntrans_bal_df.pos_sum = trans_bal_df.amount.where (trans_bal_df.operation == 'VKLAD', trans_bal_df.pos_sum )\ntrans_bal_df.pos_sum = trans_bal_df.amount.where (trans_bal_df.operation == 'PREVOD Z UCTU', trans_bal_df.pos_sum)\n\n#neg_sum stands for outflows\ntrans_bal_df.neg_sum = trans_bal_df.amount.where (trans_bal_df.operation == 'VYBER', trans_bal_df.neg_sum )\ntrans_bal_df.neg_sum = trans_bal_df.amount.where (trans_bal_df.operation == 'PREVOD NA UCET', trans_bal_df.neg_sum )\ntrans_bal_df.neg_sum = trans_bal_df.amount.where (trans_bal_df.operation == 'VYBER KARTOU', trans_bal_df.neg_sum )\n\ntrans_bal_df [trans_bal_df ['operation'] == 'VYBER'].tail (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      pos_sum\n      neg_sum\n    \n  \n  \n    \n      1055639\n      3489430\n      7520\n      1998-12-31\n      VYDAJ\n      VYBER\n      67.2\n      -11020.4\n      SANKC. UROK\n      NaN\n      NaN\n      1998\n      NaN\n      67.2\n    \n    \n      1055676\n      3488804\n      7465\n      1998-12-31\n      VYDAJ\n      VYBER\n      0.8\n      84975.2\n      SANKC. UROK\n      NaN\n      NaN\n      1998\n      NaN\n      0.8\n    \n    \n      1055731\n      3545165\n      442\n      1998-12-31\n      VYDAJ\n      VYBER\n      0.6\n      54376.5\n      SANKC. UROK\n      NaN\n      NaN\n      1998\n      NaN\n      0.6\n    \n  \n\n\n\n\n\n#setting date as index for further visualization\ntrans_bal_df.set_index (trans_bal_df ['date'], inplace = True)\ntrans_bal_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      pos_sum\n      neg_sum\n    \n    \n      date\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1993-01-01\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      1993\n      700.0\n      NaN\n    \n    \n      1993-01-01\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      1993\n      900.0\n      NaN\n    \n    \n      1993-01-01\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      1993\n      1000.0\n      NaN\n    \n  \n\n\n\n\n\n#Outflows and inflows trends - years aggregation\ninflows = trans_bal_df['pos_sum'].resample('Y').sum ()\noutflows = trans_bal_df['neg_sum'].resample('Y').sum ()\n\nplt.style.use('fivethirtyeight')\nx = outflows.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (inflows / 1000000) \ny2 = list (outflows / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Inflows')\nax.plot(x, y2, label = 'Outflows' )#, figsize = (8,8))\nax.set_title(\"Outflows and inflows trends (years)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#Outflows and inflows trends - months aggregation\ninflows = trans_bal_df['pos_sum'].resample('M').sum ()\noutflows = trans_bal_df['neg_sum'].resample('M').sum ()\n\nplt.style.use('fivethirtyeight')\nx = outflows.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (inflows / 1000000) \ny2 = list (outflows / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Inflows')\nax.plot(x, y2, label = 'Outflows' )#, figsize = (8,8))\nax.set_title(\"Outflows and inflows trends (months)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#Outflows and inflows trends - days aggregation\ninflows = trans_bal_df['pos_sum'].resample('D').sum ()\noutflows = trans_bal_df['neg_sum'].resample('D').sum ()\n\nplt.style.use('fivethirtyeight')\nx = outflows.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (inflows / 1000000) \ny2 = list (outflows / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Inflows')\nax.plot(x, y2, label = 'Outflows' )#, figsize = (8,8))\nax.set_title(\"Outflows and inflows trends (days)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#verifying overall balance of inflows and outflows for the whole reported period\ndisplay (trans_bal_df['neg_sum'].sum ())\ndisplay (trans_bal_df['pos_sum'].sum ())\n\n3030321135.799999\n\n\n3200001735.0\n\n\n\n#Outflows details investigation\n\ntrans_negflow_df = trans_df.copy ()\n\n#column with amounts that stand for cash withdrawal \ntrans_negflow_df = trans_negflow_df.assign (cw_sum = np.nan)\n\n#column with amounts that stand for withdrawal from credit card \ntrans_negflow_df = trans_negflow_df.assign (cwc_sum = np.nan)\n\n#column with amounts that stand for remittance to another banks \ntrans_negflow_df = trans_negflow_df.assign (rem_sum = np.nan)\n\n#filling columns pos_sum and neg_sum based on operation type. pos_sum stands for inflows\ntrans_negflow_df.cw_sum = trans_negflow_df.amount.where (trans_negflow_df.operation == 'VYBER', trans_negflow_df.cw_sum )\ntrans_negflow_df.cwc_sum = trans_negflow_df.amount.where (trans_negflow_df.operation == 'VYBER KARTOU', trans_negflow_df.cwc_sum)\ntrans_negflow_df.rem_sum = trans_negflow_df.amount.where (trans_negflow_df.operation == 'PREVOD NA UCET', trans_negflow_df.rem_sum)\n\n#trans_negflow_df [trans_negflow_df ['operation'] == 'PREVOD NA UCET'].head (n=5)\n\n\n#setting date as index for further visualization\ntrans_negflow_df.set_index (trans_negflow_df ['date'], inplace = True)\ntrans_negflow_df.head (n=3)\n\n\n\n\n\n  \n    \n      \n      trans_id\n      account_id\n      date\n      type\n      operation\n      amount\n      balance\n      k_symbol\n      bank\n      account\n      tran_year\n      cw_sum\n      cwc_sum\n      rem_sum\n    \n    \n      date\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1993-01-01\n      695247\n      2378\n      1993-01-01\n      PRIJEM\n      VKLAD\n      700.0\n      700.0\n      NaN\n      NaN\n      NaN\n      1993\n      NaN\n      NaN\n      NaN\n    \n    \n      1993-01-01\n      171812\n      576\n      1993-01-01\n      PRIJEM\n      VKLAD\n      900.0\n      900.0\n      NaN\n      NaN\n      NaN\n      1993\n      NaN\n      NaN\n      NaN\n    \n    \n      1993-01-01\n      207264\n      704\n      1993-01-01\n      PRIJEM\n      VKLAD\n      1000.0\n      1000.0\n      NaN\n      NaN\n      NaN\n      1993\n      NaN\n      NaN\n      NaN\n    \n  \n\n\n\n\n\n#plotting results outflows decomposition (years)\ncashw = trans_negflow_df['cw_sum'].resample('Y').sum ()\ncashw_card = trans_negflow_df['cwc_sum'].resample('Y').sum ()\nremit = trans_negflow_df['rem_sum'].resample('Y').sum ()\n\nplt.style.use('fivethirtyeight')\nx = cashw.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (cashw / 1000000) \ny2 = list (remit / 1000000)\ny3 = list (cashw_card / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Cash withdrawal')\nax.plot(x, y2, label = 'Remittance to another banks' )#, figsize = (8,8))\nax.plot(x, y3, label = 'Cash withdrawal from credit card' )#, figsize = (8,8))\nax.set_title(\"Outflows decomposition (years)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n#plotting results outflows decomposition (months)\ncashw = trans_negflow_df['cw_sum'].resample('M').sum ()\ncashw_card = trans_negflow_df['cwc_sum'].resample('M').sum ()\nremit = trans_negflow_df['rem_sum'].resample('M').sum ()\n\nplt.style.use('fivethirtyeight')\nx = cashw.index\nfig, ax = plt.subplots(figsize = (10,6))\ny1 = list (cashw / 1000000) \ny2 = list (remit / 1000000)\ny3 = list (cashw_card / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Cash withdrawal')\nax.plot(x, y2, label = 'Remittance to another banks' )#, figsize = (8,8))\nax.plot(x, y3, label = 'Cash withdrawal from credit card' )#, figsize = (8,8))\nax.set_title(\"Outflows decomposition (months)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\npd.DataFrame (cashw/1000000).head (n=24)\n\n\n\n\n\n  \n    \n      \n      cw_sum\n    \n    \n      date\n      \n    \n  \n  \n    \n      1993-01-31\n      0.034700\n    \n    \n      1993-02-28\n      0.271815\n    \n    \n      1993-03-31\n      0.852493\n    \n    \n      1993-04-30\n      2.026936\n    \n    \n      1993-05-31\n      3.897119\n    \n    \n      1993-06-30\n      7.180022\n    \n    \n      1993-07-31\n      6.676697\n    \n    \n      1993-08-31\n      7.994952\n    \n    \n      1993-09-30\n      8.471902\n    \n    \n      1993-10-31\n      10.318828\n    \n    \n      1993-11-30\n      10.782028\n    \n    \n      1993-12-31\n      15.199389\n    \n    \n      1994-01-31\n      21.031592\n    \n    \n      1994-02-28\n      9.571364\n    \n    \n      1994-03-31\n      13.809816\n    \n    \n      1994-04-30\n      13.718473\n    \n    \n      1994-05-31\n      15.815229\n    \n    \n      1994-06-30\n      25.609627\n    \n    \n      1994-07-31\n      15.466124\n    \n    \n      1994-08-31\n      15.846305\n    \n    \n      1994-09-30\n      16.992539\n    \n    \n      1994-10-31\n      17.482733\n    \n    \n      1994-11-30\n      17.032683\n    \n    \n      1994-12-31\n      23.894643\n    \n  \n\n\n\n\nPeaks of cashwithdrawal in Jan (rarely Feb) and June.\n\n#plotting results outflows decomposition (days)\ncashw = trans_negflow_df['cw_sum'].resample('D').sum ()\ncashw_card = trans_negflow_df['cwc_sum'].resample('D').sum ()\nremit = trans_negflow_df['rem_sum'].resample('D').sum ()\n\nplt.style.use('fivethirtyeight')\nx = cashw.index\nfig, ax = plt.subplots(figsize = (15,6))\ny1 = list (cashw / 1000000) \ny2 = list (remit / 1000000)\ny3 = list (cashw_card / 1000000)\nax.set_ylabel('Millions')\nax.plot(x, y1, label = 'Cash withdrawal')\nax.plot(x, y2, label = 'Remittance to another banks' )#, figsize = (8,8))\nax.plot(x, y3, label = 'Cash withdrawal from credit card' )#, figsize = (8,8))\nax.set_title(\"Outflows decomposition (days)\")\nplt.legend (loc = 'best')\nplt.show()\n\n\n\n\n\n\n\n\nTransaction types distribution in the dataset: traditionally cash withdrawal is the most popular operation (41%), 19% for remittance from another banks, 17% for interest credit, the least used is cash withdrawal from credit card which is reasonable as this transaction is usually chargeable for customers.\n\nTransactions distribution within given period (1993-1998) mostly the same. Despite the fact that number of transaction for remittance to another bank is bigger than number of collection from another banks (in some years more than 2 times), overall sum within year is smaller and the balance is positive.\nInflows prevail over outflows during reported period (year, months) although in some specific days it is different."
  },
  {
    "objectID": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html",
    "href": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html",
    "title": "Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric",
    "section": "",
    "text": "Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric"
  },
  {
    "objectID": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#data",
    "href": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#data",
    "title": "Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric",
    "section": "Data",
    "text": "Data\n\nimport torch\nfrom torch_geometric.data import Data\n\n\nx = torch.tensor([[2,1], [5,6], [3,7], [12,0]], dtype=torch.float)\ny = torch.tensor([0, 1, 0, 1], dtype=torch.float)\n\nedge_index = torch.tensor([[0, 2, 1, 0, 3],\n                           [3, 1, 0, 1, 2]], dtype=torch.long)\n\n\ndata = Data(x=x, y=y, edge_index=edge_index)\n\n\ndata\n\nData(x=[4, 2], edge_index=[2, 5], y=[4])"
  },
  {
    "objectID": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#dataset",
    "href": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#dataset",
    "title": "Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric",
    "section": "Dataset",
    "text": "Dataset\n\nInMemoryDataset\n- raw_file_names()\n- processed_file_names()\n- dowanload()\n\n작업 중인 데이터를 self.raw_dir에 지정된 디렉터리로 다운로드, 데이터 다운이 필요 없으면 pass\n\n- process()\n\nself.collate()를 호출하여 DataLoader 객체에서 사용할 슬라이스를 계산\n\nimport torch\nfrom torch_geometric.data import InMemoryDataset\n\n\nclass MyOwnDataset(InMemoryDataset):\n    def __init__(self, root, transform=None, pre_transform=None):\n        super(MyOwnDataset, self).__init__(root, transform, pre_transform)\n        self.data, self.slices = torch.load(self.processed_paths[0])\n\n    @property\n    def raw_file_names(self):\n        return ['some_file_1', 'some_file_2', ...]\n\n    @property\n    def processed_file_names(self):\n        return ['data.pt']\n\n    def download(self):\n        # Download to `self.raw_dir`.\n\n    def process(self):\n        # Read data into huge `Data` list.\n        data_list = [...]\n\n        if self.pre_filter is not None:\n            data_list [data for data in data_list if self.pre_filter(data)]\n\n        if self.pre_transform is not None:\n            data_list = [self.pre_transform(data) for data in data_list]\n\n        data, slices = self.collate(data_list)\n        torch.save((data, slices), self.processed_paths[0])"
  },
  {
    "objectID": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#dataloader",
    "href": "posts/hadamangeo/Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric.html#dataloader",
    "title": "Hands-on Graph Neural Networks with PyTorch & PyTorch Geometric",
    "section": "DataLoader",
    "text": "DataLoader\n\nfrom torch.utils.data import DataLoader\n\n\nloader = DataLoader(dataset, batch_size=512, shuffle=True)\n\n\nfor batch in loader:\n    batch\n    >>> Batch(x=[1024, 21], edge_index=[2, 1568], y=[512], batch=[1024])"
  },
  {
    "objectID": "posts/hadamangeo/graph4-3.html",
    "href": "posts/hadamangeo/graph4-3.html",
    "title": "CH4. 지도 그래프 학습(그래프 정규화 방법)",
    "section": "",
    "text": "그래프 머신러닝\ngithub"
  },
  {
    "objectID": "posts/hadamangeo/graph4-3.html#load-dataset",
    "href": "posts/hadamangeo/graph4-3.html#load-dataset",
    "title": "CH4. 지도 그래프 학습(그래프 정규화 방법)",
    "section": "Load Dataset",
    "text": "Load Dataset\n- 데이터셋: Cora\n\n7개의 클래스로 라벨링돼 있는 2,708개의 컴퓨터 사이언스 논문\n각 논문은 인용을 기반으로 다른 노드와 연결된 노드\n총 5,429개의 간선\n\n\nfrom stellargraph import datasets\n\n2023-04-06 21:44:50.486139: I tensorflow/core/platform/cpu_feature_guard.cc:193] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 FMA\nTo enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n\n\n\ndataset = datasets.Cora()\n\n\n%config Completer.use_jedi = False\n\n\ndataset.download()\n\n\nlabel_index = {\n      'Case_Based': 0,\n      'Genetic_Algorithms': 1,\n      'Neural_Networks': 2,\n      'Probabilistic_Methods': 3,\n      'Reinforcement_Learning': 4,\n      'Rule_Learning': 5,\n      'Theory': 6,\n  }\n\n\nG, labels = dataset.load()\n\n\nG: 네트워크 노드, 간선, BOW표현 설명\nlabea : 논문id와 클래스 중 하나 사이의 매핑\n훈련 샘플: 이웃과 관련된 정보가 포함 -> 훈련을 정규화 하는데 사용\n검증 샘플: 이웃과 관련된 정보 불포함 , 예측된 라벨은 노드 특증, bow표현에만 의존\n\n\nimport numpy as np\nfrom sklearn import preprocessing, feature_extraction, model_selection\n\n\nimport tensorflow as tf\nfrom tensorflow.train import Example, Features, Feature, Int64List, BytesList, FloatList\n\n\nGRAPH_PREFIX=\"NL_nbr\"\n\n\ndef _int64_feature(*value):\n    \"\"\"Returns int64 tf.train.Feature from a bool / enum / int / uint.\"\"\"\n    return Feature(int64_list=Int64List(value=list(value)))\n\ndef _bytes_feature(value):\n    \"\"\"Returns bytes tf.train.Feature from a string.\"\"\"\n    return Feature(\n        bytes_list=BytesList(value=[value.encode('utf-8')])\n    )\n\ndef _float_feature(*value):\n    return Feature(float_list=FloatList(value=list(value)))\n\n\n_int64_feature 함수는 bool, enum, int, uint 데이터 타입을 입력 받아 int64_list 타입의 tf.train.Feature 객체를 반환\n_bytes_feature 함수는 문자열 값을 입력 받아 utf-8로 인코딩하여 bytes_list 타입의 tf.train.Feature 객체를 반환\n_float_feature 함수는 float 데이터 타입을 입력 받아 float_list 타입의 tf.train.Feature 객체를 반환\n\n- 반지도 학습 데이터 셋 만드는 함수 정의\n\nfrom functools import reduce\nfrom typing import List, Tuple\nimport pandas as pd\nimport six\n\ndef addFeatures(x, y):\n    res = Features()\n    res.CopyFrom(x)\n    res.MergeFrom(y)\n    return res\n\ndef neighborFeatures(features: Features, weight: float, prefix: str):  # 객체, 가중치, 접두어 입력으로 받음\n    data = {f\"{prefix}_weight\": _float_feature(weight)}\n    for name, feature in six.iteritems(features.feature):\n        data[f\"{prefix}_{name}\"] = feature \n    return Features(feature=data)\n\ndef neighborsFeatures(neighbors: List[Tuple[Features, float]]):\n    return reduce(\n        addFeatures, \n        [neighborFeatures(sample, weight, f\"{GRAPH_PREFIX}_{ith}\") for ith, (sample, weight) in enumerate(neighbors)],\n        Features()\n    )\n\ndef getNeighbors(idx, adjMatrix, topn=5): #인덱스와 인접행렬 이용하여 이웃 데이터셋 추출 \n    weights = adjMatrix.loc[idx]\n    return weights[weights>0].sort_values(ascending=False).head(topn).to_dict()\n    \n\ndef semisupervisedDataset(G, labels, ratio=0.2, topn=5):  #라벨이 있는 데이터와 없는 데이터 추출\n     #ratio:라벨 유무 비율 설정\n     #topn: 함수에서 추출할 이웃 데이터셋 크기 설정\n    n = int(np.round(len(labels)*ratio)) \n    \n    labelled, unlabelled = model_selection.train_test_split(\n        labels, train_size=n, test_size=None, stratify=labels\n    )\n\n\n1. 노드 특징 df로 구성하고 그래프 인접행렬로 저장\n\nadjMatrix = pd.DataFrame.sparse.from_spmatrix(G.to_adjacency_matrix(), index=G.nodes(), columns=G.nodes())\n    \nfeatures = pd.DataFrame(G.node_features(), index=G.nodes())\n\n\n\n2. adjMatrix사용해 노드ID와 간선 가중치 반환하여 노드의 가장 가까운 TOPN이웃 검색하는 도우미 함수 구현\n\ndef getNeighbors(idx, adjMatrix, topn=5): #인덱스와 인접행렬 이용하여 이웃 데이터셋 추출 \n    weights = adjMatrix.loc[idx]\n    neighbors = weights[weights>0]\\\n        .sort_values(ascending=False)\\\n        .head(topn)\n    return [(k,v) for k, v in neighbors.iteritems()]\n    \n\n\n3. 정보를 단일 df로 병합\n\ndataset = {\n        index: Features(feature = {\n            #\"id\": _bytes_feature(str(index)), \n            \"id\": _int64_feature(index),\n            \"words\": _float_feature(*[float(x) for x in features.loc[index].values]), \n            \"label\": _int64_feature(label_index[label])\n        })\n        for index, label in pd.concat([labelled, unlabelled]).items()\n    }\n\nNameError: name 'labelled' is not defined\n\n\n\nfrom functools import reduce\nfrom typing import List, Tuple\nimport pandas as pd\nimport six\n\ndef addFeatures(x, y):\n    res = Features()\n    res.CopyFrom(x)\n    res.MergeFrom(y)\n    return res\n\ndef neighborFeatures(features: Features, weight: float, prefix: str):\n    data = {f\"{prefix}_weight\": _float_feature(weight)}\n    for name, feature in six.iteritems(features.feature):\n        data[f\"{prefix}_{name}\"] = feature \n    return Features(feature=data)\n\ndef neighborsFeatures(neighbors: List[Tuple[Features, float]]):\n    return reduce(\n        addFeatures, \n        [neighborFeatures(sample, weight, f\"{GRAPH_PREFIX}_{ith}\") for ith, (sample, weight) in enumerate(neighbors)],\n        Features()\n    )\n\ndef getNeighbors(idx, adjMatrix, topn=5):\n    weights = adjMatrix.loc[idx]\n    return weights[weights>0].sort_values(ascending=False).head(topn).to_dict()\n    \n\ndef semisupervisedDataset(G, labels, ratio=0.2, topn=5):\n    n = int(np.round(len(labels)*ratio))\n    \n    labelled, unlabelled = model_selection.train_test_split(\n        labels, train_size=n, test_size=None, stratify=labels\n    )\n    \n    adjMatrix = pd.DataFrame.sparse.from_spmatrix(G.to_adjacency_matrix(), index=G.nodes(), columns=G.nodes())\n    \n    features = pd.DataFrame(G.node_features(), index=G.nodes())\n    \n    dataset = {\n        index: Features(feature = {\n            #\"id\": _bytes_feature(str(index)), \n            \"id\": _int64_feature(index),\n            \"words\": _float_feature(*[float(x) for x in features.loc[index].values]), \n            \"label\": _int64_feature(label_index[label])\n        })\n        for index, label in pd.concat([labelled, unlabelled]).items()\n    }\n    \n    trainingSet = [\n        Example(features=addFeatures(\n            dataset[exampleId], \n            neighborsFeatures(\n                [(dataset[nodeId], weight) for nodeId, weight in getNeighbors(exampleId, adjMatrix, topn).items()]\n            )\n        ))\n        for exampleId in labelled.index\n    ]\n    \n    testSet = [Example(features=dataset[exampleId]) for exampleId in unlabelled.index]\n\n    serializer = lambda _list: [e.SerializeToString() for e in _list]\n    \n    return serializer(trainingSet), serializer(testSet)"
  },
  {
    "objectID": "posts/hadamangeo/ml with python 8.html",
    "href": "posts/hadamangeo/ml with python 8.html",
    "title": "지도 학습",
    "section": "",
    "text": "ref\n\n선형대수와 통계학으로 배우는 머신러닝 with 파이썬\ngithub\n\n\n\nk-최근법 이웃 알고리즘\n\n\n# 데이터 불러오기\nfrom sklearn import datasets\nraw_iris = datasets.load_iris()\n\n# 피쳐/타겟\nX = raw_iris.data\ny = raw_iris.target\n\n# 트레이닝/테스트 데이터 분할\nfrom sklearn.model_selection import train_test_split\nX_tn, X_te, y_tn, y_te=train_test_split(X,y,random_state=0)\n\n#데이터 표준화\nfrom sklearn.preprocessing import StandardScaler\nstd_scale = StandardScaler()\nstd_scale.fit(X_tn)\nX_tn_std = std_scale.transform(X_tn)\nX_te_std  = std_scale.transform(X_te)\n\n\n# 학습\nfrom sklearn.neighbors import KNeighborsClassifier\nclf_knn =  KNeighborsClassifier(n_neighbors=2)\nclf_knn.fit(X_tn_std, y_tn)\n\nKNeighborsClassifier(n_neighbors=2)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KNeighborsClassifierKNeighborsClassifier(n_neighbors=2)\n\n\n\n# 예측\nknn_pred = clf_knn.predict(X_te_std)\nprint(knn_pred)\n\n[2 1 0 2 0 2 0 1 1 1 1 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0\n 2]\n\n\n\n# 정확도\nfrom sklearn.metrics import accuracy_score\naccuracy = accuracy_score(y_te, knn_pred)\nprint(accuracy)\n\n0.9473684210526315\n\n\n\n# confusion matrix 확인 \nfrom sklearn.metrics import confusion_matrix\nconf_matrix = confusion_matrix(y_te, knn_pred)\nprint(conf_matrix)\n\n[[13  0  0]\n [ 0 15  1]\n [ 0  1  8]]\n\n\n\n# 분류 레포트 확인\nfrom sklearn.metrics import classification_report\nclass_report = classification_report(y_te, knn_pred)\nprint(class_report)\n\n              precision    recall  f1-score   support\n\n           0       1.00      1.00      1.00        13\n           1       0.94      0.94      0.94        16\n           2       0.89      0.89      0.89         9\n\n    accuracy                           0.95        38\n   macro avg       0.94      0.94      0.94        38\nweighted avg       0.95      0.95      0.95        38\n\n\n\n\n\n선형 회귀 분석\nfrom sklearn import datasets\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.linear_model import LinearRegression \n\nfrom sklearn.metrics import r2_score\nfrom sklearn.metrics import mean_squared_error\n\n\n# 데이터 불러오기\nraw_boston = datasets.load_boston()\n\n# 피쳐, 타겟 데이터 지정\nX = raw_boston.data\ny = raw_boston.target\n\n# 트레이닝/테스트 데이터 분할\nX_tn, X_te, y_tn, y_te = train_test_split(X,y,random_state=1)\n\n\n# 데이터 표준화\nstd_scale = StandardScaler()\nstd_scale.fit(X_tn)\nX_tn_std = std_scale.transform(X_tn)\nX_te_std  = std_scale.transform(X_te)\n\n# 선형 회귀분석 학습\nclf_lr =  LinearRegression()\nclf_lr.fit(X_tn_std, y_tn)\n\n# 선형 회귀분석 모형 추정 계수 확인\nprint(clf_lr.coef_)\nprint(clf_lr.intercept_)\n\n# 릿지 회귀분석(L2 제약식 적용)\nclf_ridge = Ridge(alpha=1)\nclf_ridge.fit(X_tn_std, y_tn)\n\n# 릿지 회귀분석 모형 추정 계수 확인\nprint(clf_ridge.coef_)\nprint(clf_ridge.intercept_)\n\n# 라쏘 회귀분석(L1 제약식 적용)\nclf_lasso = Lasso(alpha=0.01)\nclf_lasso.fit(X_tn_std, y_tn)\n\n# 라쏘 회귀분석 모형 추정 계수 확인\nprint(clf_lasso.coef_)\nprint(clf_lasso.intercept_)\n\n# 엘라스틱넷\nclf_elastic = ElasticNet(alpha=0.01, l1_ratio=0.01)\nclf_elastic.fit(X_tn_std, y_tn)\n\n# 엘라스틱넷 모형 추정 계수 확인\nprint(clf_elastic.coef_)\nprint(clf_elastic.intercept_)\n\n# 예측\npred_lr = clf_lr.predict(X_te_std)\npred_ridge = clf_ridge.predict(X_te_std)\npred_lasso = clf_lasso.predict(X_te_std)\npred_elastic = clf_elastic.predict(X_te_std)\n\n# 모형 평가-R제곱값\nprint(r2_score(y_te, pred_lr))\nprint(r2_score(y_te, pred_ridge))\nprint(r2_score(y_te, pred_lasso))\nprint(r2_score(y_te, pred_elastic))\n\n# 모형 평가-MSE\nprint(mean_squared_error(y_te, pred_lr))\nprint(mean_squared_error(y_te, pred_ridge))\nprint(mean_squared_error(y_te, pred_lasso))\nprint(mean_squared_error(y_te, pred_elastic))\n- 회귀분석\n\\[\\hat w = (X^TX)^{-1}X^Ty\\]\n- 릿지 회귀 분석(L2제약식)\n\\[\\hat w^{ridge} = (X^TX+ \\lambda I_p)^{-1}X^Ty\\]\n\n\\(\\lambda\\) 계수의 사이즈 조절, 정규식의 크기 조절, 0에 가까울수록 최소 제곱 추정량에 가까워지며 무한대에 가까워질수록 릿지 해는 0에 가까워짐\n편향(bias)가 존재\n\n- 라쏘 회귀 분석(L1제약식)\n\\[\\hat w^{lasso}=argmin_w \\{(y-Xw)^T(y-Xw)+\\lambda(|w|-t) \\}\\]\n\n\n로지스틱 회귀 분석\n\n# 데이터 불러오기\nfrom sklearn import datasets\nraw_cancer = datasets.load_breast_cancer()\n\n# 피쳐, 타겟 데이터 지정\nX = raw_cancer.data\ny = raw_cancer.target\n\n# 트레이닝/테스트 데이터 분할\nfrom sklearn.model_selection import train_test_split\nX_tn, X_te, y_tn, y_te=train_test_split(X,y,random_state=0)\n\n\n\n\n#데이터 표준화\nfrom sklearn.preprocessing import StandardScaler\nstd_scale = StandardScaler()\nstd_scale.fit(X_tn)\nX_tn_std = std_scale.transform(X_tn)\nX_te_std  = std_scale.transform(X_te)\n\n\n# 로지스틱 회귀분석(L2 제약식 적용)\nfrom sklearn.linear_model import LogisticRegression\nclf_logi_l2 =  LogisticRegression(penalty='l2')\nclf_logi_l2.fit(X_tn_std, y_tn)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n\n# 로지스틱 회귀분석 모형(L2 제약식 적용) 추정 계수\nprint(clf_logi_l2.coef_) # 추정 계수\nprint(clf_logi_l2.intercept_) # 상수항\n\n[[-0.29792942 -0.58056355 -0.3109406  -0.377129   -0.11984232  0.42855478\n  -0.71131106 -0.85371164 -0.46688191  0.11762548 -1.38262136  0.0899184\n  -0.94778563 -0.94686238  0.18575731  0.99305313  0.11090349 -0.3458275\n   0.20290919  0.80470317 -0.91626377 -0.91726667 -0.8159834  -0.86539197\n  -0.45539191  0.10347391 -0.83009341 -0.98445173 -0.5920036  -0.61086989]]\n[0.02713751]\n\n\n\n# 예측\npred_logistic = clf_logi_l2.predict(X_te_std)\nprint(pred_logistic)\n\n[0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 0 0 0 0 1 1 0 1 1 0 1 0 1 0 1 0 1 0 1\n 0 1 0 0 1 0 1 1 0 1 1 1 0 0 0 0 1 1 1 1 1 1 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0\n 0 1 1 1 1 1 0 0 0 1 0 1 1 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 1\n 0 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 1 0]\n\n\n\n# 확률값으로 예측\npred_proba = clf_logi_l2.predict_proba(X_te_std)\nprint(pred_proba)\n\n[[9.98638613e-01 1.36138656e-03]\n [3.95544804e-02 9.60445520e-01]\n [1.30896362e-03 9.98691036e-01]\n [1.24473354e-02 9.87552665e-01]\n [2.44132101e-04 9.99755868e-01]\n [4.50491513e-03 9.95495085e-01]\n [1.13985968e-04 9.99886014e-01]\n [1.82475894e-03 9.98175241e-01]\n [9.67965506e-05 9.99903203e-01]\n [1.75222878e-06 9.99998248e-01]\n [1.76572612e-01 8.23427388e-01]\n [8.24119135e-02 9.17588087e-01]\n [9.66067493e-06 9.99990339e-01]\n [5.39343196e-01 4.60656804e-01]\n [3.98187854e-01 6.01812146e-01]\n [9.95762760e-01 4.23724017e-03]\n [2.75612083e-03 9.97243879e-01]\n [9.99997097e-01 2.90271401e-06]\n [9.99926506e-01 7.34935682e-05]\n [9.99999997e-01 2.78313939e-09]\n [9.98738365e-01 1.26163489e-03]\n [9.81405399e-01 1.85946008e-02]\n [1.77902039e-02 9.82209796e-01]\n [9.65876713e-04 9.99034123e-01]\n [9.99464578e-01 5.35421808e-04]\n [6.73385015e-04 9.99326615e-01]\n [5.50833875e-05 9.99944917e-01]\n [9.69828919e-01 3.01710813e-02]\n [1.62119075e-03 9.98378809e-01]\n [9.99997821e-01 2.17867101e-06]\n [6.00571253e-05 9.99939943e-01]\n [9.99954808e-01 4.51921300e-05]\n [1.09252006e-01 8.90747994e-01]\n [9.97255978e-01 2.74402243e-03]\n [4.51047979e-06 9.99995490e-01]\n [9.97449456e-01 2.55054412e-03]\n [1.97830173e-02 9.80216983e-01]\n [9.99571529e-01 4.28470822e-04]\n [8.45566258e-03 9.91544337e-01]\n [9.99487912e-01 5.12087502e-04]\n [9.42409583e-01 5.75904174e-02]\n [8.34700429e-05 9.99916530e-01]\n [9.32505814e-01 6.74941855e-02]\n [8.11944408e-05 9.99918806e-01]\n [6.08911689e-02 9.39108831e-01]\n [9.99999999e-01 1.17373572e-09]\n [1.00967748e-06 9.99998990e-01]\n [1.48182234e-02 9.85181777e-01]\n [6.33630458e-04 9.99366370e-01]\n [9.99927519e-01 7.24813084e-05]\n [9.99989528e-01 1.04724511e-05]\n [8.04262948e-01 1.95737052e-01]\n [9.99965014e-01 3.49860375e-05]\n [1.36691079e-03 9.98633089e-01]\n [1.95330244e-03 9.98046698e-01]\n [5.74609838e-04 9.99425390e-01]\n [1.05063052e-03 9.98949369e-01]\n [7.96089471e-03 9.92039105e-01]\n [1.00288029e-02 9.89971197e-01]\n [9.99999999e-01 1.44073341e-09]\n [9.97609027e-01 2.39097260e-03]\n [9.99257870e-01 7.42129950e-04]\n [3.14309030e-05 9.99968569e-01]\n [4.40044150e-03 9.95599559e-01]\n [9.99897373e-01 1.02627439e-04]\n [1.52976144e-01 8.47023856e-01]\n [1.00000000e+00 2.39185116e-13]\n [9.99998777e-01 1.22317020e-06]\n [9.99999046e-01 9.53579837e-07]\n [7.96239235e-04 9.99203761e-01]\n [3.87033734e-01 6.12966266e-01]\n [9.99993469e-01 6.53125942e-06]\n [2.97085842e-03 9.97029142e-01]\n [8.09412134e-01 1.90587866e-01]\n [9.99996998e-01 3.00240009e-06]\n [1.75950117e-02 9.82404988e-01]\n [4.94325863e-05 9.99950567e-01]\n [3.51047770e-02 9.64895223e-01]\n [4.25841119e-04 9.99574159e-01]\n [2.09232609e-05 9.99979077e-01]\n [9.82374564e-01 1.76254356e-02]\n [1.00000000e+00 3.57855006e-10]\n [9.99988747e-01 1.12526453e-05]\n [5.94724730e-05 9.99940528e-01]\n [9.62731634e-01 3.72683662e-02]\n [1.69452548e-03 9.98305475e-01]\n [6.14966533e-05 9.99938503e-01]\n [6.36886875e-06 9.99993631e-01]\n [9.99902779e-01 9.72205364e-05]\n [1.00000000e+00 8.14423797e-11]\n [3.47458432e-05 9.99965254e-01]\n [5.53589378e-01 4.46410622e-01]\n [6.91462937e-01 3.08537063e-01]\n [9.99996851e-01 3.14924112e-06]\n [2.01951834e-03 9.97980482e-01]\n [2.39759190e-03 9.97602408e-01]\n [9.99999992e-01 7.92006333e-09]\n [1.03400237e-02 9.89659976e-01]\n [9.23218910e-03 9.90767811e-01]\n [9.80048490e-04 9.99019952e-01]\n [5.45753731e-09 9.99999995e-01]\n [3.09034901e-03 9.96909651e-01]\n [6.22819445e-03 9.93771806e-01]\n [1.49494565e-01 8.50505435e-01]\n [9.99994787e-01 5.21292981e-06]\n [6.02188244e-04 9.99397812e-01]\n [9.99995658e-01 4.34219020e-06]\n [9.49795077e-02 9.05020492e-01]\n [3.27428663e-01 6.72571337e-01]\n [1.72350019e-02 9.82764998e-01]\n [3.75686888e-02 9.62431311e-01]\n [9.99975711e-01 2.42887910e-05]\n [9.99911399e-01 8.86014791e-05]\n [8.65663331e-02 9.13433667e-01]\n [8.21398481e-04 9.99178602e-01]\n [2.45946373e-02 9.75405363e-01]\n [1.43898490e-01 8.56101510e-01]\n [1.58128486e-03 9.98418715e-01]\n [1.79682971e-02 9.82031703e-01]\n [1.18803803e-03 9.98811962e-01]\n [1.55728346e-02 9.84427165e-01]\n [1.43822197e-03 9.98561778e-01]\n [3.86829219e-01 6.13170781e-01]\n [2.65232841e-02 9.73476716e-01]\n [9.99999918e-01 8.17382381e-08]\n [1.28424726e-01 8.71575274e-01]\n [4.67709202e-01 5.32290798e-01]\n [2.58725940e-04 9.99741274e-01]\n [3.25269018e-05 9.99967473e-01]\n [4.00075207e-05 9.99959992e-01]\n [9.99901036e-01 9.89636008e-05]\n [1.27248974e-04 9.99872751e-01]\n [2.66411581e-04 9.99733588e-01]\n [2.13163719e-01 7.86836281e-01]\n [2.92511631e-02 9.70748837e-01]\n [2.37309476e-05 9.99976269e-01]\n [5.09465728e-01 4.90534272e-01]\n [6.17881971e-01 3.82118029e-01]\n [1.00000000e+00 1.46648090e-12]\n [8.41453252e-05 9.99915855e-01]\n [1.58701592e-03 9.98412984e-01]\n [1.26424968e-03 9.98735750e-01]\n [9.99999994e-01 5.81805301e-09]]\n\n\n\n# 정밀도\nfrom sklearn.metrics import precision_score\nprecision = precision_score(y_te, pred_logistic)\nprint(precision)\n\n0.9666666666666667\n\n\n\n# confusion matrix 확인 \nfrom sklearn.metrics import confusion_matrix\nconf_matrix = confusion_matrix(y_te, pred_logistic)\nprint(conf_matrix)\n\n[[50  3]\n [ 3 87]]\n\n\n\n# 분류 레포트 확인\nfrom sklearn.metrics import classification_report\nclass_report = classification_report(y_te, pred_logistic)\nprint(class_report)\n\n              precision    recall  f1-score   support\n\n           0       0.94      0.94      0.94        53\n           1       0.97      0.97      0.97        90\n\n    accuracy                           0.96       143\n   macro avg       0.96      0.96      0.96       143\nweighted avg       0.96      0.96      0.96       143\n\n\n\n\n\n나이브 베이즈(추후 다시)\nfrom sklearn import datasets\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n\nfrom sklearn.naive_bayes import GaussianNB\n\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\n\n\n# 데이터 불러오기\nraw_wine = datasets.load_wine()\n\n# 피쳐, 타겟 데이터 지정\nX = raw_wine.data\ny = raw_wine.target\n\n# 트레이닝/테스트 데이터 분할\nX_tn, X_te, y_tn, y_te=train_test_split(X,y,random_state=0)\n\n# 데이터 표준화\nstd_scale = StandardScaler()\nstd_scale.fit(X_tn)\nX_tn_std = std_scale.transform(X_tn)\nX_te_std  = std_scale.transform(X_te)\n\n# 나이브 베이즈 학습\nclf_gnb = GaussianNB()\nclf_gnb.fit(X_tn_std, y_tn)\n\n# 예측\npred_gnb = clf_gnb.predict(X_te_std)\nprint(pred_gnb)\n\n# 리콜\nrecall = recall_score(y_te, pred_gnb, average='macro')\nprint(recall)\n\n# confusion matrix 확인 \nconf_matrix = confusion_matrix(y_te, pred_gnb)\nprint(conf_matrix)\n\n# 분류 레포트 확인\nclass_report = classification_report(y_te, pred_gnb)\nprint(class_report)\n\n\n의사결정나무(추후 다시)\n\n테스트 성능 평가는 엔트로피 이용\n엔트로피는 불순도(노드에 서로 다른 데이터가 얼마나 섞여 있는지) 정도를 측정하며 낮을수록 좋다.\n\n\\[Entropy(d) = - \\sum p(x) log P(x)\\]\n\\[= - \\sum_{i=1}^k p(i|d)log_2(p(i|d))\\]\n\n# 데이터 불러오기\nfrom sklearn import datasets\nraw_wine = datasets.load_wine()\n\n# 피쳐, 타겟 데이터 지정\nX = raw_wine.data\ny = raw_wine.target\n\n# 트레이닝/테스트 데이터 분할\nfrom sklearn.model_selection import train_test_split\nX_tn, X_te, y_tn, y_te=train_test_split(X,y,random_state=0)\n\n# 데이터 표준화\nfrom sklearn.preprocessing import StandardScaler\nstd_scale = StandardScaler()\nstd_scale.fit(X_tn)\nX_tn_std = std_scale.transform(X_tn)\nX_te_std  = std_scale.transform(X_te)\n\n\n# 의사결정나무 학습\nfrom sklearn import tree \nclf_tree = tree.DecisionTreeClassifier(random_state=0)\nclf_tree.fit(X_tn_std, y_tn)\n\n\nDecisionTreeClassifier(random_state=0)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.DecisionTreeClassifierDecisionTreeClassifier(random_state=0)\n\n\n\n# 예측\npred_tree = clf_tree.predict(X_te_std)\nprint(pred_tree)\n\n\n[0 2 1 0 1 1 0 2 1 1 2 2 0 1 2 1 0 0 2 0 1 0 1 1 1 1 1 1 1 2 0 0 1 0 0 0 2\n 1 1 2 1 0 1 1 1]\n\n\n\n# f1 score\nfrom sklearn.metrics import f1_score\nf1 = f1_score(y_te, pred_tree, average='macro')\nprint(f1)\n\n0.9349141206870346\n\n\n\n# confusion matrix 확인 \nfrom sklearn.metrics import confusion_matrix\nconf_matrix = confusion_matrix(y_te, pred_tree)\nprint(conf_matrix)\n\n[[14  2  0]\n [ 0 20  1]\n [ 0  0  8]]\n\n\n\n# 분류 레포트 확인\nfrom sklearn.metrics import classification_report\nclass_report = classification_report(y_te, pred_tree)\nprint(class_report)\n\n              precision    recall  f1-score   support\n\n           0       1.00      0.88      0.93        16\n           1       0.91      0.95      0.93        21\n           2       0.89      1.00      0.94         8\n\n    accuracy                           0.93        45\n   macro avg       0.93      0.94      0.93        45\nweighted avg       0.94      0.93      0.93        45\n\n\n\n\n\n서포트 벡터 머신(추후 다시)\n\n\n크로스 밸리데이션(추후 다시)"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html",
    "href": "posts/hadamangeo/coin prediction.html",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "",
    "text": "python-data-analysis data\nData Source\n이것이 데이터 분석이다 with 파이썬\n\n%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html#arima",
    "href": "posts/hadamangeo/coin prediction.html#arima",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "ARIMA",
    "text": "ARIMA\n\nAR:자기 자신의 과거를 정보로 사용. > 현재의 상태는 이전의 상태를 참고해서 계산\nMA: 이전 항에서의 오차를 이용해 현재 항의 상태 추론\nARMA: AR+MA\nARIMA: ARMA모델에 추세 변동 경향성 반영\n\n- 만약 ARIMA클래스 order=(2,1,2)이라면\n\n첫번째 2: AR이 몇번째 과거까지 바라보는지\n두번째 1: 차분(difference) - 현재 상태의 변수에서 바로 전 상태의 변수를 빼줌(경향성)\n세번째 2: MA가 몇번째 과거까지 바라보는지\n\n\nfrom statsmodels.tsa.arima.model import ARIMA\n\nimport statsmodels.api as sm"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html#학습",
    "href": "posts/hadamangeo/coin prediction.html#학습",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "학습",
    "text": "학습\n\n\nmodel = ARIMA(bitcoin_df.price.values, order=(2, 1, 2))\nmodel_fit = model.fit()\nprint(model_fit.summary())\n\n                               SARIMAX Results                                \n==============================================================================\nDep. Variable:                      y   No. Observations:                  365\nModel:                 ARIMA(2, 1, 2)   Log Likelihood               -2787.490\nDate:                Thu, 18 May 2023   AIC                           5584.980\nTime:                        14:55:27   BIC                           5604.466\nSample:                             0   HQIC                          5592.725\n                                - 365                                         \nCovariance Type:                  opg                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nar.L1          0.2418      0.305      0.794      0.427      -0.355       0.839\nar.L2          0.6072      0.200      3.038      0.002       0.215       0.999\nma.L1         -0.1513      0.306     -0.495      0.621      -0.751       0.448\nma.L2         -0.6705      0.205     -3.279      0.001      -1.071      -0.270\nsigma2      2.624e+05   1.05e+04     24.899      0.000    2.42e+05    2.83e+05\n===================================================================================\nLjung-Box (L1) (Q):                   0.07   Jarque-Bera (JB):               721.96\nProb(Q):                              0.79   Prob(JB):                         0.00\nHeteroskedasticity (H):               0.14   Skew:                             0.01\nProb(H) (two-sided):                  0.00   Kurtosis:                         9.90\n===================================================================================\n\nWarnings:\n[1] Covariance matrix calculated using the outer product of gradients (complex-step).\n\n\nfig = model_fit.plot_predict() # 학습 데이터에 대한 예측 결과입니다. (첫번째 그래프)\nresiduals = pd.DataFrame(model_fit.resid) # 잔차의 변동을 시각화합니다. (두번째 그래프)\nresiduals.plot()\nforecast_data = model_fit.forecast(steps=5) # 학습 데이터셋으로부터 5일 뒤를 예측합니다.\n\n# 테스트 데이터셋을 불러옵니다.\ntest_file_path = '../data/market-price-test.csv'\nbitcoin_test_df = pd.read_csv(test_file_path, names=['ds', 'y'])\n\npred_y = forecast_data[0].tolist() # 마지막 5일의 예측 데이터입니다. (2018-08-27 ~ 2018-08-31)\ntest_y = bitcoin_test_df.y.values # 실제 5일 가격 데이터입니다. (2018-08-27 ~ 2018-08-31)\npred_y_lower = [] # 마지막 5일의 예측 데이터의 최소값입니다.\npred_y_upper = [] # 마지막 5일의 예측 데이터의 최대값입니다.\nfor lower_upper in forecast_data[2]:\n    lower = lower_upper[0]\n    upper = lower_upper[1]\n    pred_y_lower.append(lower)\n    pred_y_upper.append(upper)\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(pred_y_lower, color=\"red\") # 모델이 예상한 최소가격 그래프입니다.\nplt.plot(pred_y_upper, color=\"blue\") # 모델이 예상한 최대가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom math import sqrt\n\nrmse = sqrt(mean_squared_error(pred_y, test_y))\nprint(rmse)"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html#상한가-및-하한가-선정",
    "href": "posts/hadamangeo/coin prediction.html#상한가-및-하한가-선정",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "상한가 및 하한가 선정",
    "text": "상한가 및 하한가 선정\n\nbitcoin_df = pd.read_csv(file_path, names=['ds', 'y'])\n\n# 상한가를 설정합니다.\nbitcoin_df['cap'] = 20000\n\n# 상한가 적용을 위한 파라미터를 다음과 같이 설정합니다.\nprophet = Prophet(seasonality_mode='multiplicative', \n                  growth='logistic',\n                  yearly_seasonality=True,\n                  weekly_seasonality=True, daily_seasonality=True,\n                  changepoint_prior_scale=0.5)\nprophet.fit(bitcoin_df)\n\n\n\n# 5일을 내다보며 예측합니다.\nfuture_data = prophet.make_future_dataframe(periods=5, freq='d')\n\n# 상한가를 설정합니다.\nfuture_data['cap'] = 20000\nforecast_data = prophet.predict(future_data)\n\n\nfig = prophet.plot(forecast_data)\n\n\nbitcoin_test_df = pd.read_csv(test_file_path, names=['ds', 'y'])\n\n# 모델이 예상한 마지막 5일의 가격 데이터를 가져옵니다.\npred_y = forecast_data.yhat.values[-5:]\ntest_y = bitcoin_test_df.y.values\npred_y_lower = forecast_data.yhat_lower.values[-5:]\npred_y_upper = forecast_data.yhat_upper.values[-5:]\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(pred_y_lower, color=\"red\") # 모델이 예상한 최소가격 그래프입니다.\nplt.plot(pred_y_upper, color=\"blue\") # 모델이 예상한 최대가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\nrmse = sqrt(mean_squared_error(pred_y, test_y))\nprint(rmse)"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html#이상치-제거",
    "href": "posts/hadamangeo/coin prediction.html#이상치-제거",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "이상치 제거",
    "text": "이상치 제거\n\n# 18000 이상의 데이터는 이상치라고 판단\nbitcoin_df = pd.read_csv(file_path, names=['ds', 'y'])\nbitcoin_df.loc[bitcoin_df['y'] > 18000, 'y'] = None\n\n\n# prophet 모델을 학습합니다.\nprophet = Prophet(seasonality_mode='multiplicative',\n                  yearly_seasonality=True,\n                  weekly_seasonality=True, daily_seasonality=True,\n                  changepoint_prior_scale=0.5)\nprophet.fit(bitcoin_df)\n\n# 5일단위의 미래를 예측합니다.\nfuture_data = prophet.make_future_dataframe(periods=5, freq='d')\nforecast_data = prophet.predict(future_data)\n\n# 예측 결과를 그래프로 출력합니다.\nfig = prophet.plot(forecast_data)\n\n\nbitcoin_test_df = pd.read_csv(test_file_path, names = ['ds', 'y'])\n\n# 모델이 예상한 마지막 5일의 가격 데이터를 가져옵니다.\npred_y = forecast_data.yhat.values[-5:]\ntest_y = bitcoin_test_df.y.values\npred_y_lower = forecast_data.yhat_lower.values[-5:]\npred_y_upper = forecast_data.yhat_upper.values[-5:]\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(pred_y_lower, color=\"red\") # 모델이 예상한 최소가격 그래프입니다.\nplt.plot(pred_y_upper, color=\"blue\") # 모델이 예상한 최대가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\nplt.plot(pred_y, color=\"gold\") # 모델이 예상한 가격 그래프입니다.\nplt.plot(test_y, color=\"green\") # 실제 가격 그래프입니다.\n\n\n# 테스트 데이터의 RMSE를 출력합니다.\nrmse = sqrt(mean_squared_error(pred_y, test_y))\nprint(rmse)"
  },
  {
    "objectID": "posts/hadamangeo/coin prediction.html#arima-모델의-하이퍼-파라미터-선정하기",
    "href": "posts/hadamangeo/coin prediction.html#arima-모델의-하이퍼-파라미터-선정하기",
    "title": "미래 예측 데이터 분석(비트코인 시세 예측)",
    "section": "ARIMA 모델의 하이퍼 파라미터 선정하기",
    "text": "ARIMA 모델의 하이퍼 파라미터 선정하기\n\nbitcoin_df = pd.read_csv(file_path, names = ['day', 'price'])\nbitcoin_df['day'] = pd.to_datetime(bitcoin_df['day'])\nbitcoin_df.index = bitcoin_df['day']\nbitcoin_df.set_index('day', inplace=True)\n\n\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\n\nplot_acf(bitcoin_df.price.values)\nplot_pacf(bitcoin_df.price.values)\nplt.show()\n\n\nmodel = ARIMA(bitcoin_df.price.values, order=(15,2,0))\nmodel_fit = model.fit(trend='c',full_output=True, disp=True)\nprint(model_fit.summary())\n\n\nmodel = ARIMA(bitcoin_df.price.values, order=(2,1,2))\nmodel_fit = model.fit(trend='c',full_output=True, disp=True)\nprint(model_fit.summary())"
  },
  {
    "objectID": "posts/학회.html",
    "href": "posts/학회.html",
    "title": "Scribbling",
    "section": "",
    "text": "일정:23. 6.29(목) ~ 7.1 (토)\n장소: 부경대학교(부산)\n발표신청 및 초록제출: 3.20.(월) ~ 4.20.(목)\n발표요약본제출(석사과정) : ~4.20.(목)\n포스터파일제출: ~ 5.19.(금)\n\n\n\n\n\n하계: 2023. 7.6.(목) ~ 7.7.(금)\n고려대학교\n발표신청 및 사전등록: 23.5.29.(월)\n초록 또는 논문제출: ~5.31.(수)\n\n\n\n\n\n일정: 6.23.(금) ~ 6.24.(토)\n장소: 강릉원주대학교\n발표논문 초록 제출: ~5.5.(금)\n발표 논문 제출: ~6.16.(금)\n학생논문: ~6.9.(금)"
  },
  {
    "objectID": "posts/TS8.html",
    "href": "posts/TS8.html",
    "title": "TS HW8",
    "section": "",
    "text": "모수 \\(\\theta\\)에 대한 서로 독립인 비편향 추정량 \\(\\hat \\theta_1\\)과 \\(\\hat \\theta_2\\)이 존재하며 \\(Var(\\hat \\theta_i)=\\sigma_i^2, i=1,2\\)이라고 한다. 이를 이용하여 새로운 추정량 \\(\\hat \\theta_{a_1,a_2}=a_1\\hat \\theta_1+ a_2 \\hat \\theta_2\\)를 정의할 때 다음에 답하시오.\n\n\n\\(\\hat \\theta_{a_1,a_2}\\)이 비편향추정량이 될 \\(a_1\\)과 \\(a_2\\)의 조건을 구하시오\n\\(E(a_1\\hat \\theta_1 + a_2 \\hat \\theta_2) = a_1E(\\hat \\theta_1) + a_2 E(\\hat \\theta_2) = \\theta(a_1+a_2)=\\theta\\)\n\\(\\therefore a_1+a_2=1\\)\n\n\n\n비편향추정량인 \\(\\hat \\theta_{a_1,a_2}\\) 중에서 가장 작은 분산을 가지는 추정량을 구하시오."
  },
  {
    "objectID": "posts/TS8.html#section-2",
    "href": "posts/TS8.html#section-2",
    "title": "TS HW8",
    "section": "(1)",
    "text": "(1)\n\\(p(1-p)\\)에 대한 비편향추정량의 크래며-라오 하한값을 구하시오\n\\(f(x|p)=p^x(1-p)^{1-x}\\)\n\\(I(p) = E\\left(\\left(\\dfrac{d}{dp}log f(x|p)\\right)^2 \\right)=E\\left(\\left(\\dfrac{d}{dp}[xlogp+(1-x)log(1-p)]\\right)^2 \\right)=E\\left(\\left(\\dfrac{x}{p}-\\dfrac{1-x}{1-p}\\right)^2\\right)=E\\left(\\left(\\dfrac{x-p}{p(1-p)}\\right)^2\\right)=\\dfrac{1}{p^2(1-p)^2}E((x-p)^2)\\)\n\\(\\because E((x-p)^2)=Var\\)~\\(p(1-p)\\)\n\\(=\\dfrac{p(1-p)}{p^2(1-p)^2}=\\dfrac{1}{p(1-p)}\\)\n\\(\\therefore CRLB = \\dfrac{g'(p))^2}{nI(p)}=\\dfrac{p(1-p)(1-2p)^2}{n}\\)"
  },
  {
    "objectID": "posts/TS8.html#section-3",
    "href": "posts/TS8.html#section-3",
    "title": "TS HW8",
    "section": "(2)",
    "text": "(2)\n\\(X_1(1-X_2)\\)의 기댓값을 구하시오."
  },
  {
    "objectID": "posts/TS8.html#section-4",
    "href": "posts/TS8.html#section-4",
    "title": "TS HW8",
    "section": "(3)",
    "text": "(3)\n\\(p(1-p)\\)에 대한 최소분산 비편향추정량을 구하시오.\n\\(E(\\bar X_n - \\bar X_n^2) = \\dfrac{(n-1)(1-p)}{n}\\)\n\\(\\dfrac{n\\bar X_n(1- \\bar X_n)}{n-1}\\)"
  },
  {
    "objectID": "posts/TS8.html#section-5",
    "href": "posts/TS8.html#section-5",
    "title": "TS HW8",
    "section": "(4)",
    "text": "(4)\n\\(p(1-p)\\)에 대한 적률추정량을 구하시오."
  },
  {
    "objectID": "posts/TS8.html#section-6",
    "href": "posts/TS8.html#section-6",
    "title": "TS HW8",
    "section": "(5)",
    "text": "(5)\n\\(p(1-p)\\)에 대한 최대가능도추정량을 구하시오."
  },
  {
    "objectID": "posts/TS8.html#section-7",
    "href": "posts/TS8.html#section-7",
    "title": "TS HW8",
    "section": "(1)",
    "text": "(1)\n\\(\\theta\\)에 대한 적절한 추축변량을 구하고, 해당 추축변량의 분포를 명시하시오."
  },
  {
    "objectID": "posts/TS8.html#section-8",
    "href": "posts/TS8.html#section-8",
    "title": "TS HW8",
    "section": "(2)",
    "text": "(2)\n\\(\\theta\\)에 대한 95% 신뢰구간을 구하시오."
  },
  {
    "objectID": "posts/TS8.html#section-9",
    "href": "posts/TS8.html#section-9",
    "title": "TS HW8",
    "section": "(3)",
    "text": "(3)\n\\(P(X>1)\\)에 대한 95% 신뢰구간을 구하시오."
  },
  {
    "objectID": "posts/사기거래/낙서.html",
    "href": "posts/사기거래/낙서.html",
    "title": "Scribbling",
    "section": "",
    "text": "import numpy as np\n\n# 구한 행렬\nmatrix = np.array([[0, 5, 10, 15, 20],\n                   [5, 0, 5, 10, 15],\n                   [10, 5, 0, 5, 10],\n                   [15, 10, 5, 0, 5],\n                   [20, 15, 10, 5, 0]])\n\n# exp(-a_ij) 계산\nresult = np.exp(-matrix)\n\n# 결과 확인\nprint(result)\n\n[[1.00000000e+00 6.73794700e-03 4.53999298e-05 3.05902321e-07\n  2.06115362e-09]\n [6.73794700e-03 1.00000000e+00 6.73794700e-03 4.53999298e-05\n  3.05902321e-07]\n [4.53999298e-05 6.73794700e-03 1.00000000e+00 6.73794700e-03\n  4.53999298e-05]\n [3.05902321e-07 4.53999298e-05 6.73794700e-03 1.00000000e+00\n  6.73794700e-03]\n [2.06115362e-09 3.05902321e-07 4.53999298e-05 6.73794700e-03\n  1.00000000e+00]]\n\n\n\nimport numpy as np\n\n# 구한 행렬\nmatrix = np.array([[0, 5, 10, 15, 20],\n                   [5, 0, 5, 10, 15],\n                   [10, 5, 0, 5, 10],\n                   [15, 10, 5, 0, 5],\n                   [20, 15, 10, 5, 0]])\n\n# 행렬의 상관 계수 행렬 구하기\ncorr_matrix = np.corrcoef(matrix)\n\n# 각 행렬의 값을 corr로 나누기\nresult = matrix / corr_matrix\nresult = np.exp(-result)\n# 결과 확인\nprint(result)\n\n[[1.00000000e+00 2.45592422e-03 0.00000000e+00 6.75079804e+07\n  4.85165195e+08]\n [2.45592422e-03 1.00000000e+00 6.62778420e-06 1.16270342e+08\n  6.75079804e+07]\n [0.00000000e+00 6.62778420e-06 1.00000000e+00 6.62778420e-06\n  0.00000000e+00]\n [6.75079804e+07 1.16270342e+08 6.62778420e-06 1.00000000e+00\n  2.45592422e-03]\n [4.85165195e+08 6.75079804e+07 0.00000000e+00 2.45592422e-03\n  1.00000000e+00]]\n\n\n/tmp/ipykernel_3252510/2210747788.py:14: RuntimeWarning: divide by zero encountered in true_divide\n  result = matrix / corr_matrix\n\n\n\nimport numpy as np\n\n# 데이터 준비\nx = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9],\n              [10, 11, 12],\n              [13, 14, 15]])\n\nW = np.array([[0.1],\n              [0.2],\n              [0.3]])\n\n# 예측 모델 구성\ny = np.dot(x, W)\n\n# 결과 출력\nprint(y)\n\n[[1.4]\n [3.2]\n [5. ]\n [6.8]\n [8.6]]"
  },
  {
    "objectID": "posts/사기거래/사기거래 날짜 230602.html",
    "href": "posts/사기거래/사기거래 날짜 230602.html",
    "title": "Scribbling",
    "section": "",
    "text": "신용카드 거래 사기탐지 TRY 변형"
  },
  {
    "objectID": "posts/사기거래/사기거래 날짜 230602.html#분석1",
    "href": "posts/사기거래/사기거래 날짜 230602.html#분석1",
    "title": "Scribbling",
    "section": "분석1",
    "text": "분석1\n- step1: data\n\nX = np.array(df02_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n#yyhat = lrnr.predict(XX) \n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results1= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.88678\n      0.910677\n      0.86025\n      0.884746"
  },
  {
    "objectID": "posts/사기거래/사기거래 날짜 230602.html#분석2",
    "href": "posts/사기거래/사기거래 날짜 230602.html#분석2",
    "title": "Scribbling",
    "section": "분석2",
    "text": "분석2\n- step1: data\n\ndef amtano(df_train):\n    df = df_train.copy()\n    df = df.assign(amtano1=0)\n    df = df.assign(amtano2=0)\n    df = df.assign(amtano3=0)\n    normalize = lambda arr: (arr-np.median(arr)) if np.std(arr)!=0 else arr*0 \n    rollmax = lambda arr: arr.rolling(window=3, min_periods=1).max()\n    rollmin = lambda arr: arr.rolling(window=3, min_periods=1).min()    \n    rollmean = lambda arr: arr.rolling(window=3, min_periods=1).mean()    \n    rollstd = lambda arr: arr.rolling(window=3, min_periods=1).std()    \n    for cc_num, sub_df in df.groupby('cc_num'):\n        df.loc[df.cc_num == cc_num,['amtano1']] = normalize(sub_df.amt)\n        df.loc[df.cc_num == cc_num,['amtano2']] = (sub_df.amt * rollmean(normalize(sub_df.amt)))/rollmin(sub_df.amt)\n        df.loc[df.cc_num == cc_num,['amtano3']] = rollmin(normalize(sub_df.amt))\n    return df  \n\n\ndf02_tr2 = amtano(df02_tr)\ndf50_test2 = amtano(df50_test)\n\nX = np.array(df02_tr2.loc[:,['amtano2']])\nXX = np.array(df50_test2.loc[:,['amtano2']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n\ncclist = df02_tr2.cc_num.unique().tolist()\n\n\ni=190\nplt.plot(df02_tr2.query('cc_num==@cclist[@i]').trans_date_trans_time, df02_tr2.query('cc_num==@cclist[@i]').amt,'o')\nplt.plot(df02_tr2.query('cc_num==@cclist[@i]').trans_date_trans_time, df02_tr2.query('cc_num==@cclist[@i]').is_fraud*df02_tr2.query('cc_num==@cclist[@i]').amt,'x')\n\n\n\n\n- step2: lrnr\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\n# thresh = y.mean()\n# yyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\nyyhat = lrnr.predict(XX) \n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results2= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.53047\n      0.908397\n      0.078444\n      0.144417"
  },
  {
    "objectID": "posts/사기거래/사기거래 날짜 230602.html#분석-정리",
    "href": "posts/사기거래/사기거래 날짜 230602.html#분석-정리",
    "title": "Scribbling",
    "section": "분석 정리",
    "text": "분석 정리\n\npd.concat([_results1,_results2])\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.88678\n      0.910677\n      0.860250\n      0.884746\n    \n    \n      분석2\n      0.53047\n      0.908397\n      0.078444\n      0.144417"
  },
  {
    "objectID": "posts/사기거래/9999.html",
    "href": "posts/사기거래/9999.html",
    "title": "Scribbling",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport networkx as nx\nimport sklearn\n\n# split \nfrom sklearn.model_selection import train_test_split\n\n# embedding \nfrom node2vec import Node2Vec\nfrom node2vec.edges import HadamardEmbedder, AverageEmbedder, WeightedL1Embedder, WeightedL2Embedder\n\n# models \nfrom sklearn.ensemble import RandomForestClassifier \n\n# 평가 \nfrom sklearn import metrics \n\n\ndef build_graph_bipartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df[\"cc_num\"].values.tolist()+\\\n                                                      df[\"merchant\"].values.tolist()))}\n    \n    df[\"from\"]=df[\"cc_num\"].apply(lambda x:mapping[x])  #엣지의 출발점\n    df[\"to\"]=df[\"merchant\"].apply(lambda x:mapping[x])  #엣지의 도착점\n    \n    df = df[['from', 'to', \"amt\", \"is_fraud\"]].groupby(['from','to']).agg({\"is_fraud\":\"sum\",\"amt\":\"sum\"}).reset_index()\n    df[\"is_fraud\"]=df[\"is_fraud\"].apply(lambda x:1 if x>0 else 0)\n    \n    G=nx.from_edgelist(df[[\"from\",\"to\"]].values, create_using=graph_type)\n    \n    nx.set_edge_attributes(G, {(int(x[\"from\"]),int(x[\"to\"])):x[\"is_fraud\"] for idx, x in df[[\"from\",\"to\",\"is_fraud\"]].iterrows()}, \"label\")  #엣지 속성 설정,각 속성의 사기 여부부 \n    \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"amt\"] for idx,x in df[[\"from\",\"to\",\"amt\"]].iterrows()}, \"weight\") # 엣지 속성 설정, 각 엣지의 거래 금액\n\n    return G\n\ndef down_sample_textbook(df):\n    df = df[df[\"is_fraud\"]==0].sample(frac=0.20, random_state=42).append(df[df[\"is_fraud\"] == 1])\n    df_majority = df[df.is_fraud==0]\n    df_minority = df[df.is_fraud==1]\n    df_maj_dowsampled = sklearn.utils.resample(df_majority, n_samples=len(df_minority), random_state=42)\n    df_downsampled = pd.concat([df_minority, df_maj_dowsampled])\n    return df_downsampled\n\ndef split(Graph,test_size=0.20,random_state=42):\n    edg = list(range(len(Graph.edges))) \n    edg_att = list(nx.get_edge_attributes(Graph, \"label\").values())\n    return train_test_split(edg,edg_att,test_size=test_size,random_state=random_state) \n\ndef embedding(Graph):\n    _edgs = list(Graph.edges)\n    _train_edges, _test_edges, y, yy = split(Graph)\n    _train_graph = Graph.edge_subgraph([_edgs[x] for x in _train_edges]).copy()\n    _train_graph.add_nodes_from(list(set(Graph.nodes) - set(_train_graph.nodes)))\n    _embedded = AverageEmbedder(Node2Vec(_train_graph, weight_key='weight').fit(window=10).wv)\n    X = [_embedded[str(_edgs[x][0]), str(_edgs[x][1])] for x in _train_edges]\n    XX = [_embedded[str(_edgs[x][0]), str(_edgs[x][1])] for x in _test_edges]\n    return X,XX,y,yy \n\ndef evaluate(lrnr,XX,yy):\n    yyhat = lrnr.predict(XX)\n    df = pd.DataFrame({'pre':[sklearn.metrics.precision_score(yy,yyhat)], \n                  'rec':[sklearn.metrics.recall_score(yy,yyhat)],\n                  'f1':[sklearn.metrics.f1_score(yy,yyhat)]})\n    return df \n\ndef anal(df,n_estimators=10):\n    Graph = build_graph_bipartite(df)\n    X,XX,y,yy = embedding(Graph)\n    lrnr = RandomForestClassifier(n_estimators=n_estimators, random_state=42) \n    lrnr.fit(X,y)\n    return lrnr, XX,yy, evaluate(lrnr,XX,yy)\n\ndef our_sampling1(df):\n    cus_list = set(df.query('is_fraud==1').cc_num.tolist())\n    return df.query(\"cc_num in @ cus_list\")"
  },
  {
    "objectID": "posts/사기거래/9999.html#read-and-define-data",
    "href": "posts/사기거래/9999.html#read-and-define-data",
    "title": "Scribbling",
    "section": "read and define data",
    "text": "read and define data\n\ndf = pd.read_csv(\"~/Desktop/fraudTrain.csv\")\n\n\n\n\n\n  \n    \n      \n      Unnamed: 0\n      trans_date_trans_time\n      cc_num\n      merchant\n      category\n      amt\n      first\n      last\n      gender\n      street\n      ...\n      lat\n      long\n      city_pop\n      job\n      dob\n      trans_num\n      unix_time\n      merch_lat\n      merch_long\n      is_fraud\n    \n  \n  \n    \n      669418\n      669418\n      2019-10-12 18:21\n      4.089100e+18\n      fraud_Haley, Jewess and Bechtelar\n      shopping_pos\n      7.53\n      Debra\n      Stark\n      F\n      686 Linda Rest\n      ...\n      32.3836\n      -94.8653\n      24536\n      Multimedia programmer\n      1983-10-14\n      d313353fa30233e5fab5468e852d22fc\n      1350066071\n      32.202008\n      -94.371865\n      0\n    \n    \n      32567\n      32567\n      2019-01-20 13:06\n      4.247920e+12\n      fraud_Turner LLC\n      travel\n      3.79\n      Judith\n      Moss\n      F\n      46297 Benjamin Plains Suite 703\n      ...\n      39.5370\n      -83.4550\n      22305\n      Television floor manager\n      1939-03-09\n      88c65b4e1585934d578511e627fe3589\n      1327064760\n      39.156673\n      -82.930503\n      0\n    \n    \n      156587\n      156587\n      2019-03-24 18:09\n      4.026220e+12\n      fraud_Klein Group\n      entertainment\n      59.07\n      Debbie\n      Payne\n      F\n      204 Ashley Neck Apt. 169\n      ...\n      41.5224\n      -71.9934\n      4720\n      Broadcast presenter\n      1977-05-18\n      3bd9ede04b5c093143d5e5292940b670\n      1332612553\n      41.657152\n      -72.595751\n      0\n    \n    \n      1020243\n      1020243\n      2020-02-25 15:12\n      4.957920e+12\n      fraud_Monahan-Morar\n      personal_care\n      25.58\n      Alan\n      Parsons\n      M\n      0547 Russell Ford Suite 574\n      ...\n      39.6171\n      -102.4776\n      207\n      Network engineer\n      1955-12-04\n      19e16ee7a01d229e750359098365e321\n      1361805120\n      39.080346\n      -103.213452\n      0\n    \n    \n      116272\n      116272\n      2019-03-06 23:19\n      4.178100e+15\n      fraud_Kozey-Kuhlman\n      personal_care\n      84.96\n      Jill\n      Flores\n      F\n      639 Cruz Islands\n      ...\n      41.9488\n      -86.4913\n      3104\n      Horticulturist, commercial\n      1981-03-29\n      a0c8641ca1f5d6e243ed5a2246e66176\n      1331075954\n      42.502065\n      -86.732664\n      0\n    \n  \n\n5 rows × 23 columns\n\n\n\n\n# df_downsampled = down_sample_textbook(df)"
  },
  {
    "objectID": "posts/사기거래/9999.html#embedding",
    "href": "posts/사기거래/9999.html#embedding",
    "title": "Scribbling",
    "section": "embedding",
    "text": "embedding\n\n#G_down = build_graph_bipartite(df_downsampled)\n\n\n# X,XX,y,yy = embedding(G_down)"
  },
  {
    "objectID": "posts/사기거래/9999.html#learn",
    "href": "posts/사기거래/9999.html#learn",
    "title": "Scribbling",
    "section": "learn",
    "text": "learn\n\n# lrnr = RandomForestClassifier(n_estimators=10, random_state=42) \n# lrnr.fit(X,y)"
  },
  {
    "objectID": "posts/사기거래/9999.html#evaluate",
    "href": "posts/사기거래/9999.html#evaluate",
    "title": "Scribbling",
    "section": "evaluate",
    "text": "evaluate\n\n# evaluate(lrnr,XX,yy)"
  },
  {
    "objectID": "posts/사기거래/9999.html#read-and-define-data-1",
    "href": "posts/사기거래/9999.html#read-and-define-data-1",
    "title": "Scribbling",
    "section": "read and define data",
    "text": "read and define data\n\ndf = pd.read_csv(\"~/Desktop/fraudTrain.csv\")\nlrnr2, _,_,_ = anal(down_sample_textbook(our_sampling1(df)),n_estimators=100)\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:03<00:00,  3.01it/s]"
  },
  {
    "objectID": "posts/사기거래/교수님 data(원본).html",
    "href": "posts/사기거래/교수님 data(원본).html",
    "title": "Scribbling",
    "section": "",
    "text": "신용카드 거래 사기탐지 TRY1"
  },
  {
    "objectID": "posts/사기거래/교수님 data(원본).html#분석",
    "href": "posts/사기거래/교수님 data(원본).html#분석",
    "title": "Scribbling",
    "section": "분석",
    "text": "분석\n\n분석1\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results1 = pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics}, index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석2\n- step1: data\n\nX = np.array(fraudTrain_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n\nthresh = fraudTrain_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results2 = pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics}, index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.829171\n      0.885561\n      0.760053\n      0.818021\n    \n  \n\n\n\n\n\n\n분석3\n- 함수\n\ndef amtano1(df_train):\n    df = df_train.copy()\n    df = df.assign(amtano=0)\n    normalize = lambda arr: (arr-np.median(arr))/np.std(arr) if np.std(arr)!=0 else arr*0\n    for cc_num, sub_df in df.groupby('cc_num'):\n        df.loc[df.cc_num == cc_num,['amtano']] = normalize(sub_df.amt).cumsum()\n        return df\n\n\ndef amtano2(dt_train, df_test):\n    df = pd.concat([df_train, df_test])\n    df_amtano = amtano_train(df)\n    return df_test.assign(amtano = df_amtano.loc[[i in df_test.index for i in df_amtano.index],'amtano'])\n\n\n# amtano2함수정확이 뭔지 헷갈려\n\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results3= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석3'])\n_results3\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석3\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석4\n- step1: data\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = fraudTrain_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results4= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석4'])\n_results4\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석4\n      0.828505\n      0.884202\n      0.760053\n      0.817441\n    \n  \n\n\n\n\n\n\n분석5\n- step1: data\n\nGtr = build_graph_bipartite(df50_tr)\nGtest = build_graph_bipartite(df50_test)\nX,y = embedding(Gtr)\nXX, yy = embedding(Gtest)\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:02<00:00,  3.41it/s]\n\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:02<00:00,  3.51it/s]\n\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results5= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석5'])\n_results5\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석5\n      0.503845\n      0.504714\n      0.921854\n      0.652296"
  },
  {
    "objectID": "posts/사기거래/교수님 data(원본).html#분석-정리",
    "href": "posts/사기거래/교수님 data(원본).html#분석-정리",
    "title": "Scribbling",
    "section": "분석 정리",
    "text": "분석 정리\n\npd.concat([_results1,_results2,_results3,_results4,_results5])\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석2\n      0.829171\n      0.885561\n      0.760053\n      0.818021\n    \n    \n      분석3\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석4\n      0.828505\n      0.884202\n      0.760053\n      0.817441\n    \n    \n      분석5\n      0.503845\n      0.504714\n      0.921854\n      0.652296"
  },
  {
    "objectID": "posts/사기거래/교수님 data(원본).html#분석-1",
    "href": "posts/사기거래/교수님 data(원본).html#분석-1",
    "title": "Scribbling",
    "section": "분석",
    "text": "분석\n\n분석1\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results1= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석2\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results2= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.885781\n      0.908206\n      0.86091\n      0.883926\n    \n  \n\n\n\n\n\n\n분석3\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results3= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석3'])\n_results3\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석3\n      0.887113\n      0.90846\n      0.863546\n      0.885434\n    \n  \n\n\n\n\n\n\n분석4\n- step1: data\n\nX = np.array(amtano1(df02_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results4= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석4'])\n_results4\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석4\n      0.88678\n      0.910677\n      0.86025\n      0.884746\n    \n  \n\n\n\n\n\n\n분석5\n- step1: data\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results5= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석5'])\n_results5\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석5\n      0.874792\n      0.878065\n      0.873434\n      0.875744"
  },
  {
    "objectID": "posts/사기거래/교수님 data(원본).html#분석정리",
    "href": "posts/사기거래/교수님 data(원본).html#분석정리",
    "title": "Scribbling",
    "section": "분석정리",
    "text": "분석정리\n\n\n\n\nTrain\nTest\n모형\n설명변수\n비고\n\n\n\n\n분석1\ndf50train\ndf50test\n로지스틱\namt\n\n\n\n분석2\ndf50train\ndf50test\n그레디언트부스팅\namt\nbase\n\n\n분석3\ndf50train\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n분석4\ndf02train\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n분석5\nfraudTrain_tr\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n\n\nlst = [_results1,_results2,_results3,_results4,_results5]\npd.concat(lst)\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석2\n      0.885781\n      0.908206\n      0.860910\n      0.883926\n    \n    \n      분석3\n      0.887113\n      0.908460\n      0.863546\n      0.885434\n    \n    \n      분석4\n      0.886780\n      0.910677\n      0.860250\n      0.884746\n    \n    \n      분석5\n      0.874792\n      0.878065\n      0.873434\n      0.875744"
  },
  {
    "objectID": "posts/사기거래/2023-05-24-try2변형.html",
    "href": "posts/사기거래/2023-05-24-try2변형.html",
    "title": "Scribbling",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport networkx as nx\nimport sklearn\n\n# sklearn\nfrom sklearn import model_selection # split함수이용\nfrom sklearn import ensemble # RF,GBM\nfrom sklearn import metrics \n\n# embedding \nfrom node2vec import Node2Vec\nfrom node2vec.edges import HadamardEmbedder, AverageEmbedder, WeightedL1Embedder, WeightedL2Embedder\n\n\ndef build_graph_bipartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df[\"cc_num\"].values.tolist()+\\\n                                                      df[\"merchant\"].values.tolist()))}\n    \n    df[\"from\"]=df[\"cc_num\"].apply(lambda x:mapping[x])  #엣지의 출발점\n    df[\"to\"]=df[\"merchant\"].apply(lambda x:mapping[x])  #엣지의 도착점\n    \n    df = df[['from', 'to', \"amt\", \"is_fraud\"]].groupby(['from','to']).agg({\"is_fraud\":\"sum\",\"amt\":\"sum\"}).reset_index()\n    df[\"is_fraud\"]=df[\"is_fraud\"].apply(lambda x:1 if x>0 else 0)\n    \n    G=nx.from_edgelist(df[[\"from\",\"to\"]].values, create_using=graph_type)\n    \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"is_fraud\"] for idx, x in df[[\"from\",\"to\",\"is_fraud\"]].iterrows()}, \"label\")  #엣지 속성 설정,각 속성의 사기 여부부     \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"amt\"] for idx,x in df[[\"from\",\"to\",\"amt\"]].iterrows()}, \"weight\") # 엣지 속성 설정, 각 엣지의 거래 금액\n\n    return G\n\n\ndef build_graph_tripartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df.index.values.tolist() + \n                                                       df[\"cc_num\"].values.tolist() +\n                                                       df[\"merchant\"].values.tolist()))}\n    df[\"in_node\"]= df[\"cc_num\"].apply(lambda x: mapping[x])\n    df[\"out_node\"]=df[\"merchant\"].apply(lambda x:mapping[x])\n    \n        \n    G=nx.from_edgelist([(x[\"in_node\"], mapping[idx]) for idx, x in df.iterrows()] +\\\n                        [(x[\"out_node\"], mapping[idx]) for idx, x in df.iterrows()], create_using=graph_type)\n    \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")     \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")   \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")  \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")\n\n    return G\n    \n    \ndef down_sample_textbook(df):\n    df_majority = df[df.is_fraud==0].copy()\n    df_minority = df[df.is_fraud==1].copy()\n    df_maj_dowsampled = sklearn.utils.resample(df_majority, n_samples=len(df_minority), replace=False, random_state=42)\n    df_downsampled = pd.concat([df_minority, df_maj_dowsampled])\n    return df_downsampled\n\ndef embedding(Graph):\n    # Graph -> X (feature)\n    _edgs = list(Graph.edges)\n    subGraph = Graph.edge_subgraph([_edgs[x] for x in range(len(Graph.edges))]).copy()\n    subGraph.add_nodes_from(list(set(Graph.nodes) - set(subGraph.nodes)))    \n    embedded = AverageEmbedder(Node2Vec(subGraph, weight_key='weight').fit(window=10).wv)\n    X = [embedded[str(_edgs[x][0]), str(_edgs[x][1])] for x in range(len(Graph.edges))]\n    # Graph -> y (label)\n    y = np.array(list(nx.get_edge_attributes(Graph, \"label\").values()))\n    return X,y \n\ndef anal(df):\n    Graph = build_graph_bipartite(df)\n    X,XX,y,yy = embedding(Graph)\n    lrnr = RandomForestClassifier(n_estimators=100, random_state=42) \n    lrnr.fit(X,y)\n    yyhat = lrnr.predict(XX)\n    df = pd.DataFrame({\n        'acc':[sklearn.metrics.accuracy_score(yy,yyhat)], \n        'pre':[sklearn.metrics.precision_score(yy,yyhat)], \n        'rec':[sklearn.metrics.recall_score(yy,yyhat)],\n        'f1':[sklearn.metrics.f1_score(yy,yyhat)]}\n    )    \n    return df\n\ndef our_sampling1(df):\n    cus_list = set(df.query('is_fraud==1').cc_num.tolist())\n    return df.query(\"cc_num in @ cus_list\")"
  },
  {
    "objectID": "posts/사기거래/2023-05-24-try2변형.html#데이터-종류",
    "href": "posts/사기거래/2023-05-24-try2변형.html#데이터-종류",
    "title": "Scribbling",
    "section": "데이터 종류",
    "text": "데이터 종류\n\nfraudTrain.csv: (1048575, 23), 기본데이터\ndf02: (214520, 23), is_fraud==0 에서는 20퍼의 샘플만, is_fraud==1 에서는 모든 샘플을 뽑아서 정리한 새로운 자료\ndf50 = (12012, 23), df20에서 is_fraud==0 와 is_fraud==1 의 비율을 맞추어서 샘플을 뽑은 것\n\n\n\n\n\n\n\n\n\n\n데이터\nshape\n사기거래빈도\n설명\n\n\n\n\nfraudTrain\n(1048575, 22)\n0.00573\n원래자료\n\n\ndf02\n(214520, 22)\n0.028\nis_fraud==0 에서는 20퍼의 샘플만, is_fraud==1 에서는 모든 샘플을 뽑아서 정리한 새로운 자료\n\n\ndf50\n(12012, 22)\n0.5\ndf02에서 사기비율을 50퍼로 맞추어 샘플링한 자료\n\n\ndf50_tr\n(9009, 22)\n0.49828\ndf50에서 랜덤으로 train/test를 분리하여 얻은 train dataset\n\n\ndf50_test\n(3003, 22)\n0.50516\ndf50에서 랜덤으로 train/test를 분리하여 얻은 test dataset\n\n\ndf02_tr\n(211517, 22)\n0.02122\ndf02에서 df50_test에 해당하는 인덱스를 제외\n\n\nfraudTrain_tr\n(1045572, 22)\n0.00429\nfraudTrain에서 df50_test에 해당하는 인덱스를 제외\n\n\n\n- fraudTrain\n\nfraudTrain = pd.read_csv(\"~/Desktop/fraudTrain.csv\").iloc[:,1:]\n\n\nfraudTrain.is_fraud.mean().round(5)\n\n0.00573\n\n\n- df20\n\n_df1 = fraudTrain[fraudTrain[\"is_fraud\"] == 0].sample(frac=0.20, random_state=42)\n_df2 = fraudTrain[fraudTrain[\"is_fraud\"] == 1]\ndf02 = pd.concat([_df1,_df2])\ndf02.shape\n\n(214520, 22)\n\n\n\ndf02.is_fraud.mean().round(5)\n\n0.028\n\n\n- df50\n\ndf50 = down_sample_textbook(df02)\ndf50.shape\n\n(12012, 22)\n\n\n\ndf50\n\n\n\n\n\n  \n    \n      \n      trans_date_trans_time\n      cc_num\n      merchant\n      category\n      amt\n      first\n      last\n      gender\n      street\n      city\n      ...\n      lat\n      long\n      city_pop\n      job\n      dob\n      trans_num\n      unix_time\n      merch_lat\n      merch_long\n      is_fraud\n    \n  \n  \n    \n      2449\n      2019-01-02 1:06\n      4.613310e+12\n      fraud_Rutherford-Mertz\n      grocery_pos\n      281.06\n      Jason\n      Murphy\n      M\n      542 Steve Curve Suite 011\n      Collettsville\n      ...\n      35.9946\n      -81.7266\n      885\n      Soil scientist\n      1988-09-15\n      e8a81877ae9a0a7f883e15cb39dc4022\n      1325466397\n      36.430124\n      -81.179483\n      1\n    \n    \n      2472\n      2019-01-02 1:47\n      3.401870e+14\n      fraud_Jenkins, Hauck and Friesen\n      gas_transport\n      11.52\n      Misty\n      Hart\n      F\n      27954 Hall Mill Suite 575\n      San Antonio\n      ...\n      29.4400\n      -98.4590\n      1595797\n      Horticultural consultant\n      1960-10-28\n      bc7d41c41103877b03232f03f1f8d3f5\n      1325468849\n      29.819364\n      -99.142791\n      1\n    \n    \n      2523\n      2019-01-02 3:05\n      3.401870e+14\n      fraud_Goodwin-Nitzsche\n      grocery_pos\n      276.31\n      Misty\n      Hart\n      F\n      27954 Hall Mill Suite 575\n      San Antonio\n      ...\n      29.4400\n      -98.4590\n      1595797\n      Horticultural consultant\n      1960-10-28\n      b98f12f4168391b2203238813df5aa8c\n      1325473523\n      29.273085\n      -98.836360\n      1\n    \n    \n      2546\n      2019-01-02 3:38\n      4.613310e+12\n      fraud_Erdman-Kertzmann\n      gas_transport\n      7.03\n      Jason\n      Murphy\n      M\n      542 Steve Curve Suite 011\n      Collettsville\n      ...\n      35.9946\n      -81.7266\n      885\n      Soil scientist\n      1988-09-15\n      397894a5c4c02e3c61c784001f0f14e4\n      1325475483\n      35.909292\n      -82.091010\n      1\n    \n    \n      2553\n      2019-01-02 3:55\n      3.401870e+14\n      fraud_Koepp-Parker\n      grocery_pos\n      275.73\n      Misty\n      Hart\n      F\n      27954 Hall Mill Suite 575\n      San Antonio\n      ...\n      29.4400\n      -98.4590\n      1595797\n      Horticultural consultant\n      1960-10-28\n      7863235a750d73a244c07f1fb7f0185a\n      1325476547\n      29.786426\n      -98.683410\n      1\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      363827\n      2019-06-17 19:30\n      2.475090e+15\n      fraud_Frami Group\n      entertainment\n      81.13\n      John\n      Miller\n      M\n      153 Mccullough Springs Apt. 857\n      Lamberton\n      ...\n      44.2378\n      -95.2739\n      1507\n      Land/geomatics surveyor\n      1993-10-12\n      c66cb411019c7dfd4d89f42a1ba4765f\n      1339961448\n      44.212695\n      -95.661879\n      0\n    \n    \n      140154\n      2019-03-17 14:33\n      2.131550e+14\n      fraud_Bahringer-Streich\n      food_dining\n      55.00\n      Christopher\n      Sheppard\n      M\n      39218 Baker Shoals\n      Bristow\n      ...\n      38.1981\n      -86.6821\n      965\n      Horticultural therapist\n      1982-02-10\n      316b9d25b9fa7d08a6831b7dab6634cd\n      1331994839\n      38.394240\n      -86.413557\n      0\n    \n    \n      860597\n      2019-12-17 12:31\n      2.280870e+15\n      fraud_Lubowitz-Walter\n      kids_pets\n      8.12\n      Katherine\n      Cooper\n      F\n      3854 Lauren Springs Suite 648\n      Oakford\n      ...\n      40.0994\n      -89.9601\n      530\n      Transport planner\n      1967-09-23\n      d92e9e63d9b24c3ccb92d05cba4cac54\n      1355747517\n      39.695248\n      -89.853063\n      0\n    \n    \n      29341\n      2019-01-18 9:20\n      4.878360e+15\n      fraud_Denesik and Sons\n      shopping_pos\n      3.52\n      Tina\n      Alvarez\n      F\n      1976 Tyler Underpass\n      Early\n      ...\n      42.4483\n      -95.1726\n      885\n      Pilot, airline\n      1949-08-14\n      8390ce51cfb8482b618ebc4ac370bcf7\n      1326878457\n      42.633204\n      -95.598143\n      0\n    \n    \n      529797\n      2019-08-16 13:17\n      4.450830e+15\n      fraud_Beier and Sons\n      home\n      84.15\n      Donna\n      Davis\n      F\n      6760 Donovan Lakes\n      Clayton\n      ...\n      34.5906\n      -95.3800\n      1760\n      Occupational psychologist\n      1972-01-20\n      04e1be9bcb18ea8b96048659bd02177b\n      1345123058\n      33.885236\n      -95.885110\n      0\n    \n  \n\n12012 rows × 22 columns\n\n\n\n\ndf50.is_fraud.mean().round(5)\n\n0.5\n\n\n- df50_tr, df50_test\n\ndf50_tr,df50_test = sklearn.model_selection.train_test_split(df50, random_state=42)\n\n\ndf50_tr.is_fraud.mean().round(5), df50_test.is_fraud.mean().round(5)\n\n(0.49828, 0.50516)\n\n\n- df02_tr, fraudTrain_tr\n\ndf02_tr = df02.loc[[i not in df50_test.index for i in df02.index],:].copy()\nfraudTrain_tr = fraudTrain.loc[[i not in df50_test.index for i in fraudTrain.index],:].copy()\n\n\ndf02_tr.shape, fraudTrain_tr.shape\n\n((211517, 22), (1045572, 22))\n\n\n\ndf02_tr.is_fraud.mean().round(5), fraudTrain_tr.is_fraud.mean().round(5)\n\n(0.02122, 0.00429)"
  },
  {
    "objectID": "posts/사기거래/교수님 data(re).html",
    "href": "posts/사기거래/교수님 data(re).html",
    "title": "Scribbling",
    "section": "",
    "text": "신용카드 거래 사기탐지 TRY 변형"
  },
  {
    "objectID": "posts/사기거래/교수님 data(re).html#분석1",
    "href": "posts/사기거래/교수님 data(re).html#분석1",
    "title": "Scribbling",
    "section": "분석1",
    "text": "분석1\n- step1: data\n\nX = np.array(df02_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n#yyhat = lrnr.predict(XX) \n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results1= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.88678\n      0.910677\n      0.86025\n      0.884746"
  },
  {
    "objectID": "posts/사기거래/교수님 data(re).html#분석2",
    "href": "posts/사기거래/교수님 data(re).html#분석2",
    "title": "Scribbling",
    "section": "분석2",
    "text": "분석2\n- step1: data\n\ndef amtano(df_train):\n    df = df_train.copy()\n    df = df.assign(amtano1=0)\n    df = df.assign(amtano2=0)\n    df = df.assign(amtano3=0)\n    normalize = lambda arr: (arr-np.median(arr)) if np.std(arr)!=0 else arr*0 \n    rollmax = lambda arr: arr.rolling(window=3, min_periods=1).max()\n    rollmin = lambda arr: arr.rolling(window=3, min_periods=1).min()    \n    rollmean = lambda arr: arr.rolling(window=3, min_periods=1).mean()    \n    rollstd = lambda arr: arr.rolling(window=3, min_periods=1).std()    \n    for cc_num, sub_df in df.groupby('cc_num'):\n        df.loc[df.cc_num == cc_num,['amtano1']] = normalize(sub_df.amt)\n        df.loc[df.cc_num == cc_num,['amtano2']] = (sub_df.amt * rollmean(normalize(sub_df.amt)))/rollmin(sub_df.amt)\n        df.loc[df.cc_num == cc_num,['amtano3']] = rollmin(normalize(sub_df.amt))\n    return df  \n\n\ndf02_tr2 = amtano(df02_tr)\ndf50_test2 = amtano(df50_test)\n\nX = np.array(df02_tr2.loc[:,['amtano2']])\nXX = np.array(df50_test2.loc[:,['amtano2']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n\ncclist = df02_tr2.cc_num.unique().tolist()\n\n\ni=190\nplt.plot(df02_tr2.query('cc_num==@cclist[@i]').trans_date_trans_time, df02_tr2.query('cc_num==@cclist[@i]').amt,'o')\nplt.plot(df02_tr2.query('cc_num==@cclist[@i]').trans_date_trans_time, df02_tr2.query('cc_num==@cclist[@i]').is_fraud*df02_tr2.query('cc_num==@cclist[@i]').amt,'x')\n\n\n\n\n- step2: lrnr\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\n# thresh = y.mean()\n# yyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\nyyhat = lrnr.predict(XX) \n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results2= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.53047\n      0.908397\n      0.078444\n      0.144417"
  },
  {
    "objectID": "posts/사기거래/교수님 data(re).html#분석-정리",
    "href": "posts/사기거래/교수님 data(re).html#분석-정리",
    "title": "Scribbling",
    "section": "분석 정리",
    "text": "분석 정리\n\npd.concat([_results1,_results2])\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.88678\n      0.910677\n      0.860250\n      0.884746\n    \n    \n      분석2\n      0.53047\n      0.908397\n      0.078444\n      0.144417"
  },
  {
    "objectID": "posts/사기거래/교수님.html",
    "href": "posts/사기거래/교수님.html",
    "title": "Scribbling",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport networkx as nx\nimport sklearn\n\n# sklearn\nfrom sklearn import model_selection # split함수이용\nfrom sklearn import ensemble # RF \nfrom sklearn import metrics \n\n# embedding \nfrom node2vec import Node2Vec\nfrom node2vec.edges import HadamardEmbedder, AverageEmbedder, WeightedL1Embedder, WeightedL2Embedder\n\n\ndef build_graph_bipartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df[\"cc_num\"].values.tolist()+\\\n                                                      df[\"merchant\"].values.tolist()))}\n    \n    df[\"from\"]=df[\"cc_num\"].apply(lambda x:mapping[x])  #엣지의 출발점\n    df[\"to\"]=df[\"merchant\"].apply(lambda x:mapping[x])  #엣지의 도착점\n    \n    df = df[['from', 'to', \"amt\", \"is_fraud\"]].groupby(['from','to']).agg({\"is_fraud\":\"sum\",\"amt\":\"sum\"}).reset_index()\n    df[\"is_fraud\"]=df[\"is_fraud\"].apply(lambda x:1 if x>0 else 0)\n    \n    G=nx.from_edgelist(df[[\"from\",\"to\"]].values, create_using=graph_type)\n    \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"is_fraud\"] for idx, x in df[[\"from\",\"to\",\"is_fraud\"]].iterrows()}, \"label\")  #엣지 속성 설정,각 속성의 사기 여부부     \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"amt\"] for idx,x in df[[\"from\",\"to\",\"amt\"]].iterrows()}, \"weight\") # 엣지 속성 설정, 각 엣지의 거래 금액\n\n    return G\n\ndef build_graph_tripartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df.index.values.tolist() + \n                                                       df[\"cc_num\"].values.tolist() +\n                                                       df[\"merchant\"].values.tolist()))}\n    df[\"in_node\"]= df[\"cc_num\"].apply(lambda x: mapping[x])\n    df[\"out_node\"]=df[\"merchant\"].apply(lambda x:mapping[x])\n    \n        \n    G=nx.from_edgelist([(x[\"in_node\"], mapping[idx]) for idx, x in df.iterrows()] +\\\n                        [(x[\"out_node\"], mapping[idx]) for idx, x in df.iterrows()], create_using=graph_type)\n    \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")     \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")   \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")  \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")\n\n    return G\n    \n    \ndef down_sample_textbook(df):\n    df_majority = df[df.is_fraud==0]\n    df_minority = df[df.is_fraud==1]\n    df_maj_dowsampled = sklearn.utils.resample(df_majority, n_samples=len(df_minority), random_state=42)\n    df_downsampled = pd.concat([df_minority, df_maj_dowsampled]).reset_index(drop=True)\n    df_downsampled = df_downsampled.reindex(np.random.permutation(range(df_downsampled.shape[0]))).reset_index(drop=True)\n    return df_downsampled\n\ndef embedding(Graph):\n    # Graph -> X (feature)\n    _edgs = list(Graph.edges)\n    subGraph = Graph.edge_subgraph([_edgs[x] for x in range(len(Graph.edges))]).copy()\n    subGraph.add_nodes_from(list(set(Graph.nodes) - set(subGraph.nodes)))    \n    embedded = AverageEmbedder(Node2Vec(subGraph, weight_key='weight').fit(window=10).wv)\n    X = [embedded[str(_edgs[x][0]), str(_edgs[x][1])] for x in range(len(Graph.edges))]\n    # Graph -> y (label)\n    y = np.array(list(nx.get_edge_attributes(Graph, \"label\").values()))\n    return X,y \n\ndef anal(df):\n    Graph = build_graph_bipartite(df)\n    X,XX,y,yy = embedding(Graph)\n    lrnr = RandomForestClassifier(n_estimators=100, random_state=42) \n    lrnr.fit(X,y)\n    yyhat = lrnr.predict(XX)\n    df = pd.DataFrame({\n        'acc':[sklearn.metrics.accuracy_score(yy,yyhat)], \n        'pre':[sklearn.metrics.precision_score(yy,yyhat)], \n        'rec':[sklearn.metrics.recall_score(yy,yyhat)],\n        'f1':[sklearn.metrics.f1_score(yy,yyhat)]}\n    )    \n    return df\n\ndef our_sampling1(df):\n    cus_list = set(df.query('is_fraud==1').cc_num.tolist())\n    return df.query(\"cc_num in @ cus_list\")\n\n- 원본데이터\n\nfraudTrain = pd.read_csv(\"~/Desktop/fraudTrain.csv\").iloc[:,1:]\nfraudTrain.shape\n\n(1048575, 22)\n\n\n\nfraudTrain.is_fraud.mean().round(5)\n\n0.00573\n\n\n\n총 1048575의 데이터 중 사기거래는 0.00573\n\n- 정상거래의 20퍼 랜덤샘플링\n\n_df1 = fraudTrain[fraudTrain[\"is_fraud\"] == 0].sample(frac=0.20, random_state=42)\n_df2 = fraudTrain[fraudTrain[\"is_fraud\"] == 1]\ndf02 = pd.concat([_df1,_df2])\n\n\ndf02 = pd.concat([_df1,_df2]).reset_index(drop=True)\ndf02.shape\n\n(214520, 22)\n\n\n\ndf02.is_fraud.mean().round(5)\n\n0.028\n\n\n\n총 214,502의 데이터 중 사기거래는 0.028에 해당\n\n- downsample\n\ndf50 = down_sample_textbook(df02)\ndf50.shape\n\n(12012, 22)\n\n\n\ndf50.is_fraud.mean().round(5)\n\n0.5\n\n\n\n기존 파일에서 사기거래=1인 데이터의 숫자에 맞춰 downsampling함.\n12,012의 데이터중 0.5가 사기거래 비율\n\n\ndf02_tr,df02_test = sklearn.model_selection.train_test_split(df02)\ndf50_tr,df50_test = sklearn.model_selection.train_test_split(df50)\n\n\nprint(df02_tr.shape)\nprint(df02_test.shape)\nprint(df50_tr.shape)\nprint(df50_test.shape)\n\n(160890, 22)\n(53630, 22)\n(9009, 22)\n(3003, 22)\n\n\n0.75/0.25로 나눴다.\n\n분석\n\nX=np.array(df50_tr.amt).reshape(-1,1)\nXX = np.array(df50_test.amt).reshape(-1,1)\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n\nyyhat = lrnr.predict(XX) \n\n\nyyhat\n\narray([1, 1, 1, ..., 0, 1, 0])\n\n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n{m.__name__:m(yy,yyhat).round(6) for m in metrics}\n\n{'accuracy_score': 0.867799,\n 'precision_score': 0.952188,\n 'recall_score': 0.776603,\n 'f1_score': 0.855479}\n\n\n\nGtr = build_graph_tripartite(df50_tr)\nGtest = build_graph_tripartite(df50_test)\n\n\n    df=df50.copy();graph_type=nx.Graph()\n    mapping={x:node_id for node_id, x in enumerate(set(df.index.values.tolist() + \n                                                       df[\"cc_num\"].values.tolist() +\n                                                       df[\"merchant\"].values.tolist()))}\n    df[\"in_node\"]= df[\"cc_num\"].apply(lambda x: mapping[x])\n    df[\"out_node\"]=df[\"merchant\"].apply(lambda x:mapping[x])\n    \n        \n    G=nx.from_edgelist([(x[\"in_node\"], mapping[idx]) for idx, x in df.iterrows()] +\\\n                        [(x[\"out_node\"], mapping[idx]) for idx, x in df.iterrows()], create_using=graph_type)\n    \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")\n     \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"is_fraud\"] for idx, x in df.iterrows()}, \"label\")\n    \n    nx.set_edge_attributes(G,{(x[\"in_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")\n    \n    nx.set_edge_attributes(G,{(x[\"out_node\"], mapping[idx]):x[\"amt\"] for idx, x in df.iterrows()}, \"weight\")\n    \n\n\n_G = nx.from_edgelist([[0,1],[0,2]])\n\n\nlen([(x[\"in_node\"], mapping[idx]) for idx, x in df.iterrows()] + [(x[\"out_node\"], mapping[idx]) for idx, x in df.iterrows()])\n\n24024\n\n\n\nlen(df50)\n\n12012\n\n\n\ndf[(df.is_fraud==1)&(df.cc_num==3.598900e+15)]\n\n\n\n\n\n  \n    \n      \n      trans_date_trans_time\n      cc_num\n      merchant\n      category\n      amt\n      first\n      last\n      gender\n      street\n      city\n      ...\n      city_pop\n      job\n      dob\n      trans_num\n      unix_time\n      merch_lat\n      merch_long\n      is_fraud\n      in_node\n      out_node\n    \n  \n  \n    \n      686\n      2019-11-25 22:26\n      3.598900e+15\n      fraud_Kilback LLC\n      grocery_pos\n      320.26\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      de391d925e1aa1f86cc77cf0e8f0e21b\n      1353882366\n      41.042223\n      -82.308471\n      1\n      12668\n      12614\n    \n    \n      925\n      2019-11-25 23:48\n      3.598900e+15\n      fraud_Kassulke PLC\n      shopping_net\n      948.05\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      61df1730a076116730249af6e92c3ffb\n      1353887312\n      41.157798\n      -82.108063\n      1\n      12668\n      12241\n    \n    \n      1352\n      2019-11-25 3:38\n      3.598900e+15\n      fraud_Kuvalis Ltd\n      gas_transport\n      12.63\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      4681eb64a8a2f95281afdcb7ddb43c4f\n      1353814696\n      41.082232\n      -82.864767\n      1\n      12668\n      12783\n    \n    \n      3113\n      2019-11-24 3:51\n      3.598900e+15\n      fraud_Koepp-Parker\n      grocery_pos\n      308.82\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      726d491f80a2c4db905fefe75290cdc8\n      1353729072\n      40.523117\n      -82.073365\n      1\n      12668\n      13061\n    \n    \n      3219\n      2019-11-25 22:41\n      3.598900e+15\n      fraud_Bechtelar-Rippin\n      food_dining\n      127.81\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      94f80338f56e539310f84c10c9c11fa8\n      1353883286\n      41.226756\n      -83.475536\n      1\n      12668\n      12392\n    \n    \n      7647\n      2019-11-25 22:44\n      3.598900e+15\n      fraud_Kihn, Abernathy and Douglas\n      shopping_net\n      968.41\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      2a1a6053c916e39ed512338017bed155\n      1353883476\n      41.394215\n      -82.910453\n      1\n      12668\n      13072\n    \n    \n      9546\n      2019-11-25 22:21\n      3.598900e+15\n      fraud_Heathcote, Yost and Kertzmann\n      shopping_net\n      1074.33\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      11ee1c8458d0d448d55de05c4c8a0fe9\n      1353882077\n      41.869650\n      -82.354703\n      1\n      12668\n      13303\n    \n    \n      11881\n      2019-11-24 23:35\n      3.598900e+15\n      fraud_Schaefer Ltd\n      kids_pets\n      16.53\n      Kenneth\n      Richards\n      M\n      994 Livingston Extensions Suite 918\n      Norwalk\n      ...\n      23805\n      Copy\n      1970-02-22\n      2a8b2e1497ff931108e47f5131ffbf5d\n      1353800139\n      41.431914\n      -82.661167\n      1\n      12668\n      12681\n    \n  \n\n8 rows × 24 columns\n\n\n\n\nimport matplotlib.pyplot as plt\n\n\nlen(df02.loc[(df02.cc_num==3.598900e+15),'amt'])\n\n95\n\n\n\nlen(df50.loc[(df02.cc_num==3.598900e+15),'amt'])\n\n3\n\n\n\nplt.plot(list(range(95)),df02.loc[(df02.cc_num==3.598900e+15),'amt'])\n\n\n\n\n\n_y= np.array(df02.loc[(df02.cc_num==3.598900e+15),'amt'])\n\n\ns=_y*0\n\n\nfor i in range(1,95):\n    s[i] = s[i-1] + _y[i]-np.mean(_y)\n\n\n_z=(_y-np.median(_y))/np.std(_y)\n\n\nplt.plot(_z)\n\n\n\n\n\n_t=(_y-np.mean(_y))/np.std(_y)\nplt.plot(_t)\n\n\n\n\n\nplt.plot(_z.cumsum())\n\n\n\n\n\nplt.plot(_t.cumsum())\n\n\n\n\n평균내면 -값 나와서.. 그래프가 이렇게\n\n_X,_y = embedding(Gtr)\n_XX,_yy = embedding(Gtest)\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:07<00:00,  1.39it/s]\n\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:07<00:00,  1.36it/s]\n\n\n\nprint(len(_X),len(_y), len(_XX),len(_yy))\n\n6006 6006 6006 6006\n\n\n\nprint(df50_tr.shape, len(_X), df50_test.shape, len(_XX))\n\n(9009, 22) 6006 (3003, 22) 6006\n\n\n\nX = np.array(df50_tr.amt).reshape(-1,1)\nXX = np.array(df50_test.amt).reshape(-1,1)\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n\nnp.stack(_X).shape\n\n(6006, 128)\n\n\n\nX.shape, np.stack(_X).shape\n\n((9009, 1), (6006, 128))\n\n\n_X는 그래프 임베딩 한건데, 뭘까\n\nlen(_yy),len(_y)\n\n(6006, 6006)\n\n\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n\nlrnr.fit(_X,_y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n\n_yyhat = lrnr.predict(_XX) \n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n{m.__name__:m(_yy,_yyhat).round(6) for m in metrics}\n\n{'accuracy_score': 0.511655,\n 'precision_score': 0.577371,\n 'recall_score': 0.114673,\n 'f1_score': 0.191343}\n\n\n교수님것에서는 len(_X)= 2970 나왔는데\n\nG = build_graph_bipartite(df50)\n\n\ndf50.shape\n\n(12012, 22)\n\n\n\nX,XX,y,yy = embedding(G)\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:04<00:00,  2.16it/s]\n\n\nValueError: not enough values to unpack (expected 4, got 2)\n\n\n\nnp.stack(X).shape, np.stack(XX).shape\n\n((9009, 1), (3003, 1))\n\n\n\nnp.array(y).shape,np.array(yy).shape\n\n((9009,), (3003,))\n\n\n\nfrom sklearn.ensemble import RandomForestClassifier\n\n\nlrnr = RandomForestClassifier(n_estimators=100, random_state=42) \nlrnr.fit(np.stack(X),np.array(y))\n\nRandomForestClassifier(random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(random_state=42)\n\n\n\nnp.mean(lrnr.predict(XX) == yy)\n\n0.8608058608058609\n\n\n\nanal(down_sample_textbook(df))\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:04<00:00,  2.45it/s]\n\n\nValueError: not enough values to unpack (expected 4, got 2)\n\n\n\nanal(down_sample_textbook(our_sampling1(df)))"
  },
  {
    "objectID": "posts/사기거래/graph8(frac.html",
    "href": "posts/사기거래/graph8(frac.html",
    "title": "CH8. 신용카드 거래에 대한 그래프 분석(frac=0.3)",
    "section": "",
    "text": "ref\n\n그래프 머신러닝\ngithub\nCredit Card Transactions Fraud Detection Dataset\n컬리이미지\nnetworkx\n\n\n\n신용카드 거래에 대한 그래프 분석\n\n신용카드 거래 그래프 생성\n그래프에서 속성 및 커뮤니티 추출\n사기 거래 분류에 지도 및 비지도 머신러닝 알고리즘 적용\n\n\nimport pandas as pd\n\n\nimport os\nimport math\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\ndefault_edge_color = 'gray'\ndefault_node_color = '#407cc9'\nenhanced_node_color = '#f5b042'\nenhanced_edge_color = '#cc2f04'\n\n\nimport pandas as pd\ndf = pd.read_csv(\"~/Desktop/fraudTrain.csv\")\ndf = df[df[\"is_fraud\"]==0].sample(frac=0.20, random_state=42).append(df[df[\"is_fraud\"] == 1])\ndf.head()\n\n\n\n\n\n  \n    \n      \n      Unnamed: 0\n      trans_date_trans_time\n      cc_num\n      merchant\n      category\n      amt\n      first\n      last\n      gender\n      street\n      ...\n      lat\n      long\n      city_pop\n      job\n      dob\n      trans_num\n      unix_time\n      merch_lat\n      merch_long\n      is_fraud\n    \n  \n  \n    \n      669418\n      669418\n      2019-10-12 18:21\n      4.089100e+18\n      fraud_Haley, Jewess and Bechtelar\n      shopping_pos\n      7.53\n      Debra\n      Stark\n      F\n      686 Linda Rest\n      ...\n      32.3836\n      -94.8653\n      24536\n      Multimedia programmer\n      1983-10-14\n      d313353fa30233e5fab5468e852d22fc\n      1350066071\n      32.202008\n      -94.371865\n      0\n    \n    \n      32567\n      32567\n      2019-01-20 13:06\n      4.247920e+12\n      fraud_Turner LLC\n      travel\n      3.79\n      Judith\n      Moss\n      F\n      46297 Benjamin Plains Suite 703\n      ...\n      39.5370\n      -83.4550\n      22305\n      Television floor manager\n      1939-03-09\n      88c65b4e1585934d578511e627fe3589\n      1327064760\n      39.156673\n      -82.930503\n      0\n    \n    \n      156587\n      156587\n      2019-03-24 18:09\n      4.026220e+12\n      fraud_Klein Group\n      entertainment\n      59.07\n      Debbie\n      Payne\n      F\n      204 Ashley Neck Apt. 169\n      ...\n      41.5224\n      -71.9934\n      4720\n      Broadcast presenter\n      1977-05-18\n      3bd9ede04b5c093143d5e5292940b670\n      1332612553\n      41.657152\n      -72.595751\n      0\n    \n    \n      1020243\n      1020243\n      2020-02-25 15:12\n      4.957920e+12\n      fraud_Monahan-Morar\n      personal_care\n      25.58\n      Alan\n      Parsons\n      M\n      0547 Russell Ford Suite 574\n      ...\n      39.6171\n      -102.4776\n      207\n      Network engineer\n      1955-12-04\n      19e16ee7a01d229e750359098365e321\n      1361805120\n      39.080346\n      -103.213452\n      0\n    \n    \n      116272\n      116272\n      2019-03-06 23:19\n      4.178100e+15\n      fraud_Kozey-Kuhlman\n      personal_care\n      84.96\n      Jill\n      Flores\n      F\n      639 Cruz Islands\n      ...\n      41.9488\n      -86.4913\n      3104\n      Horticulturist, commercial\n      1981-03-29\n      a0c8641ca1f5d6e243ed5a2246e66176\n      1331075954\n      42.502065\n      -86.732664\n      0\n    \n  \n\n5 rows × 23 columns\n\n\n\n\n_df = pd.read_csv(\"~/Desktop/fraudTrain.csv\")\n\n\ncus_list = set(_df.query('is_fraud==1').cc_num.tolist())\n_df2 = _df.query(\"cc_num in @ cus_list\")\n\n\n_df2.shape\n\n(651430, 23)\n\n\n\n_df2.groupby('is_fraud').agg({'category':np.sum})\n\n- 이분그래프\n\ndef build_graph_bipartite(df_input, graph_type=nx.Graph()):\n    df=df_input.copy()\n    mapping={x:node_id for node_id, x in enumerate(set(df[\"cc_num\"].values.tolist()+\\\n                                                      df[\"merchant\"].values.tolist()))}\n    \n    df[\"from\"]=df[\"cc_num\"].apply(lambda x:mapping[x])  #엣지의 출발점\n    df[\"to\"]=df[\"merchant\"].apply(lambda x:mapping[x])  #엣지의 도착점\n    \n    df = df[['from', 'to', \"amt\", \"is_fraud\"]].groupby(['from','to']).agg({\"is_fraud\":\"sum\",\"amt\":\"sum\"}).reset_index()\n    df[\"is_fraud\"]=df[\"is_fraud\"].apply(lambda x:1 if x>0 else 0)\n    \n    G=nx.from_edgelist(df[[\"from\",\"to\"]].values, create_using=graph_type)\n    \n    nx.set_edge_attributes(G, {(int(x[\"from\"]),int(x[\"to\"])):x[\"is_fraud\"] for idx, x in df[[\"from\",\"to\",\"is_fraud\"]].iterrows()}, \"label\")  #엣지 속성 설정,각 속성의 사기 여부부 \n    \n    nx.set_edge_attributes(G,{(int(x[\"from\"]),int(x[\"to\"])):x[\"amt\"] for idx,x in df[[\"from\",\"to\",\"amt\"]].iterrows()}, \"weight\") # 엣지 속성 설정, 각 엣지의 거래 금액\n\n    return G\n\n\nG_bu = build_graph_bipartite(df, nx.Graph(name=\"Bipartite Undirect\"))\n\n\n지도학습\n\nfrom sklearn.utils import resample\n\ndf_majority = df[df.is_fraud==0]\ndf_minority = df[df.is_fraud==1]\n\ndf_maj_dowsampled = resample(df_majority,\n                             n_samples=len(df_minority),\n                             random_state=42)\n\ndf_downsampled = pd.concat([df_minority, df_maj_dowsampled])\n\nprint(df_downsampled.is_fraud.value_counts())\nG_down = build_graph_bipartite(df_downsampled)\n\n1    6006\n0    6006\nName: is_fraud, dtype: int64\n\n\n\nfrom sklearn.model_selection import train_test_split\n\n\ntrain_edges, test_edges, train_labels, test_labels = train_test_split(list(range(len(G_down.edges))), \n                                                                      list(nx.get_edge_attributes(G_down, \"label\").values()), \n                                                                      test_size=0.20, \n                                                                      random_state=42)\n\n\nedgs = list(G_down.edges)\ntrain_graph = G_down.edge_subgraph([edgs[x] for x in train_edges]).copy()\ntrain_graph.add_nodes_from(list(set(G_down.nodes) - set(train_graph.nodes)))\n\n\nfrom node2vec import Node2Vec\nfrom node2vec.edges import HadamardEmbedder, AverageEmbedder, WeightedL1Embedder, WeightedL2Embedder\n\nnode2vec_train = Node2Vec(train_graph, weight_key='weight')\nmodel_train = node2vec_train.fit(window=10)\n\n\n\n\nGenerating walks (CPU: 1):   0%|          | 0/10 [00:00<?, ?it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:04<00:00,  2.48it/s]\n\n\n\nfrom sklearn.ensemble import RandomForestClassifier \nfrom sklearn import metrics \n\nclasses = [HadamardEmbedder, AverageEmbedder, WeightedL1Embedder, WeightedL2Embedder]\nfor cl in classes:\n    embeddings_train = cl(keyed_vectors=model_train.wv) \n\n\ntrain_embeddings = [embeddings_train[str(edgs[x][0]), str(edgs[x][1])] for x in train_edges]\ntest_embeddings = [embeddings_train[str(edgs[x][0]), str(edgs[x][1])] for x in test_edges]\n\n\nrf = RandomForestClassifier(n_estimators=1000, random_state=42) \n\n\nrf.fit(train_embeddings, train_labels)\n\nRandomForestClassifier(n_estimators=1000, random_state=42)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier(n_estimators=1000, random_state=42)\n\n\n\n    #\n    y_hat = rf.predict_proba(test_embeddings)\n    y_pred = np.argmax(y_hat,axis=1)\n    #y_pred = rf.predict(test_embeddings)\n\n\n\n\n    print(cl)\n    print('Precision:', metrics.precision_score(test_labels, y_pred)) \n    print('Recall:', metrics.recall_score(test_labels, y_pred)) \n    print('F1-Score:', metrics.f1_score(test_labels, y_pred)) \n\n<class 'node2vec.edges.WeightedL2Embedder'>\nPrecision: 0.6481481481481481\nRecall: 0.028641571194762683\nF1-Score: 0.054858934169278985"
  },
  {
    "objectID": "posts/사기거래/교수님 data(time12).html",
    "href": "posts/사기거래/교수님 data(time12).html",
    "title": "Scribbling",
    "section": "",
    "text": "신용카드 거래 사기탐지 TRY1"
  },
  {
    "objectID": "posts/사기거래/교수님 data(time12).html#분석",
    "href": "posts/사기거래/교수님 data(time12).html#분석",
    "title": "Scribbling",
    "section": "분석",
    "text": "분석\n\n분석1\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\nmetrics = [sklearn.metrics.accuracy_score,\n           sklearn.metrics.precision_score,\n           sklearn.metrics.recall_score,\n           sklearn.metrics.f1_score]\n\n\n_results1 = pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics}, index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석2\n- step1: data\n\nX = np.array(fraudTrain_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n\nthresh = fraudTrain_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results2 = pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics}, index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.829171\n      0.885561\n      0.760053\n      0.818021\n    \n  \n\n\n\n\n\n\n분석3\n- 함수\n\ndef amtano1(df_train):\n    df = df_train.copy()\n    df = df.assign(amtano=0)\n    normalize = lambda arr: (arr-np.median(arr))/np.std(arr) if np.std(arr)!=0 else arr*0\n    for cc_num, sub_df in df.groupby('cc_num'):\n        df.loc[df.cc_num == cc_num,['amtano']] = normalize(sub_df.amt).cumsum()\n        return df\n\n\ndef amtano2(dt_train, df_test):\n    df = pd.concat([df_train, df_test])\n    df_amtano = amtano_train(df)\n    return df_test.assign(amtano = df_amtano.loc[[i in df_test.index for i in df_amtano.index],'amtano'])\n\n\n# amtano2함수정확이 뭔지 헷갈려\n\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results3= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석3'])\n_results3\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석3\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석4\n- step1: data\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = fraudTrain_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results4= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석4'])\n_results4\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석4\n      0.828505\n      0.884202\n      0.760053\n      0.817441\n    \n  \n\n\n\n\n\n\n분석5\n- step1: data\n\nGtr = build_graph_bipartite(df50_tr)\nGtest = build_graph_bipartite(df50_test)\nX,y = embedding(Gtr)\nXX, yy = embedding(Gtest)\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:03<00:00,  3.33it/s]\n\n\n\n\n\nGenerating walks (CPU: 1): 100%|██████████| 10/10 [00:02<00:00,  3.38it/s]\n\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results5= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석5'])\n_results5\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석5\n      0.509529\n      0.50731\n      0.988079\n      0.670411\n    \n  \n\n\n\n\n\n\n분석6\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano','timee']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano','timee']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results6= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석6'])\n_results6\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석6\n      0.834166\n      0.911884\n      0.743573\n      0.819172\n    \n  \n\n\n\n\n\n\n분석7\n- step1: data\n\ny\n\narray([1, 1, 0, ..., 1, 1, 0])\n\n\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano','timee']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano','timee']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = fraudTrain_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results7= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석7'])\n_results7\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석7\n      0.707293\n      0.648787\n      0.916941\n      0.759902"
  },
  {
    "objectID": "posts/사기거래/교수님 data(time12).html#분석-정리",
    "href": "posts/사기거래/교수님 data(time12).html#분석-정리",
    "title": "Scribbling",
    "section": "분석 정리",
    "text": "분석 정리\n\n\n\n\nTrain\nTest\n모형\n설명변수\n그래프임베딩\n\n\n\n\n분석1\ndf50train\ndf50test\n로지스틱\namt\nX\n\n\n분석2\ndf02train\ndf50test\n로지스틱\namt\nX\n\n\n분석3\ndf50train\ndf50test\n로지스틱\namt,amtano\nX\n\n\n분석4\ndf02train\ndf50test\n로지스틱\namt,amtano\nX\n\n\n분석6\ndf50train\ndf50test\n로지스틱\namt,amtano,timee\nX\n\n\n분석7\ndf02train\ndf50test\n로지스틱\namt,amtano,timee\nX\n\n\n\n\npd.concat([_results1,_results2,_results3,_results4,_results5,_results6,_results7])\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석2\n      0.829171\n      0.885561\n      0.760053\n      0.818021\n    \n    \n      분석3\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석4\n      0.828505\n      0.884202\n      0.760053\n      0.817441\n    \n    \n      분석5\n      0.509529\n      0.507310\n      0.988079\n      0.670411\n    \n    \n      분석6\n      0.834166\n      0.911884\n      0.743573\n      0.819172\n    \n    \n      분석7\n      0.707293\n      0.648787\n      0.916941\n      0.759902"
  },
  {
    "objectID": "posts/사기거래/교수님 data(time12).html#분석-1",
    "href": "posts/사기거래/교수님 data(time12).html#분석-1",
    "title": "Scribbling",
    "section": "분석",
    "text": "분석\n\n분석1\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results1= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석1'])\n_results1\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n  \n\n\n\n\n\n\n분석2\n- step1: data\n\nX = np.array(df50_tr.loc[:,['amt']])\nXX = np.array(df50_test.loc[:,['amt']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results2= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석2'])\n_results2\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석2\n      0.885781\n      0.908206\n      0.86091\n      0.883926\n    \n  \n\n\n\n\n\n\n분석3\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nyyhat = lrnr.predict(XX)\n\n\n_results3= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석3'])\n_results3\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석3\n      0.887113\n      0.90846\n      0.863546\n      0.885434\n    \n  \n\n\n\n\n\n\n분석4\n- step1: data\n\nX = np.array(amtano1(df02_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results4= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석4'])\n_results4\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석4\n      0.88678\n      0.910677\n      0.86025\n      0.884746\n    \n  \n\n\n\n\n\n\n분석5\n- step1: data\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results5= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석5'])\n_results5\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석5\n      0.874792\n      0.878065\n      0.873434\n      0.875744\n    \n  \n\n\n\n\n\n\n분석6 timee\n- step1: data\n\nX = np.array(amtano1(df50_tr).loc[:,['amt','amtano','timee']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano','timee']])\ny = np.array(df50_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = sklearn.linear_model.LogisticRegression()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\n\n\n- step4: evaluate\n\nthresh = df50_tr.is_fraud.mean()\nyyhat = (lrnr.predict_proba(XX)>thresh)[:,-1]\n\n\n_results6= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석6'])\n_results6\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석6\n      0.834166\n      0.911884\n      0.743573\n      0.819172\n    \n  \n\n\n\n\n\n\n분석 7\n- step1: data\n\nX = np.array(amtano1(df02_tr).loc[:,['amt','amtano','timee']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano','timee']])\ny = np.array(df02_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results7= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석7'])\n_results7\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석7\n      0.899434\n      0.897839\n      0.903757\n      0.900788\n    \n  \n\n\n\n\n\n\n분석8\n- step1: data\n\nX = np.array(amtano1(fraudTrain_tr).loc[:,['amt','amtano','timee']])\nXX = np.array(amtano1(df50_test).loc[:,['amt','amtano','timee']])\ny = np.array(fraudTrain_tr.is_fraud)\nyy = np.array(df50_test.is_fraud)\n\n- step2: lrnr생성\n\nlrnr = ensemble.GradientBoostingClassifier()\n\n- step3: fit\n\nlrnr.fit(X,y)\n\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\n\n\n- step4: evaluate\n\nthresh = y.mean()\nyyhat = (lrnr.predict_proba(XX)> thresh)[:,-1]\n\n\n_results8= pd.DataFrame({m.__name__:[m(yy,yyhat).round(6)] for m in metrics},index=['분석8'])\n_results8\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석8\n      0.89344\n      0.892459\n      0.897165\n      0.894806"
  },
  {
    "objectID": "posts/사기거래/교수님 data(time12).html#분석정리",
    "href": "posts/사기거래/교수님 data(time12).html#분석정리",
    "title": "Scribbling",
    "section": "분석정리",
    "text": "분석정리\n\n\n\n\nTrain\nTest\n모형\n설명변수\n비고\n\n\n\n\n분석1\ndf50train\ndf50test\n로지스틱\namt\n\n\n\n분석2\ndf50train\ndf50test\n그레디언트부스팅\namt\nbase\n\n\n분석3\ndf50train\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n분석4\ndf02train\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n분석5\nfraudTrain_tr\ndf50test\n그레디언트부스팅\namt, amtano\n\n\n\n분석6\ndf50train\ndf50test\n그레디언트부스팅\namt, amtano, timee\n\n\n\n분석7\ndf02train\ndf50test\n그레디언트부스팅\namt, amtano, timee\n\n\n\n\n\nlst = [_results1,_results2,_results3,_results4,_results5,_results6,_results7,_results8]\npd.concat(lst)\n\n\n\n\n\n  \n    \n      \n      accuracy_score\n      precision_score\n      recall_score\n      f1_score\n    \n  \n  \n    \n      분석1\n      0.849484\n      0.933279\n      0.756098\n      0.835397\n    \n    \n      분석2\n      0.885781\n      0.908206\n      0.860910\n      0.883926\n    \n    \n      분석3\n      0.887113\n      0.908460\n      0.863546\n      0.885434\n    \n    \n      분석4\n      0.886780\n      0.910677\n      0.860250\n      0.884746\n    \n    \n      분석5\n      0.874792\n      0.878065\n      0.873434\n      0.875744\n    \n    \n      분석6\n      0.834166\n      0.911884\n      0.743573\n      0.819172\n    \n    \n      분석7\n      0.899434\n      0.897839\n      0.903757\n      0.900788\n    \n    \n      분석8\n      0.893440\n      0.892459\n      0.897165\n      0.894806"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "끄적끄적 coco 올리기 전 아무거나 막 쓰는 용도"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scribbling",
    "section": "",
    "text": "GNN\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nCzech Bank’s Financial Data Analysis. Moving from gut feeling to data-driven decisions.\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n2023년 학회 발표 준비\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimport\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimports\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimport\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimports\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimport\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n분석\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nimport\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nHands-on Graph Neural Networks with PyTorch & PyTorch Geometric\n\n\n\n\n\n\n\nGNN\n\n\n\n\n\n\n\n\n\n\n\nJun 2, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTS HW8\n\n\n\n\n\n\n\nTheoretical statistics\n\n\nhomework\n\n\n\n\n\n\n\n\n\n\n\nMay 31, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n미래 예측 데이터 분석(비트코인 시세 예측)\n\n\n\n\n\n\n\n회귀 분석\n\n\n\n\n\n\n\n\n\n\n\nMay 18, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n지도 학습\n\n\n\n\n\n\n\n지도 학습\n\n\n\n\n\n\n\n\n\n\n\nMay 11, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCH4. 지도 그래프 학습(그래프 정규화 방법)\n\n\n\n\n\n\n\ngraph\n\n\n\n\n\n\n\n\n\n\n\nApr 6, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCH8. 신용카드 거래에 대한 그래프 분석(frac=0.3)\n\n\n\n\n\n\n\ngraph\n\n\n\n\n\n\n\n\n\n\n\nApr 4, 2023\n\n\n김보람\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAE(-ing)\n\n\n\n\n\n\n\nVAE\n\n\nAuto-Encoding Variational Bayes\n\n\n\n\n\n\n\n\n\n\n\nMar 14, 2023\n\n\n김보람\n\n\n\n\n\n\nNo matching items"
  }
]